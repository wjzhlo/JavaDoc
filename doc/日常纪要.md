# 日常记录

##  一、Java

###  1.1日志 slf4j、log4j、logback

#### 1.1.1 三者关系

slf4j 是表层框架，而 log4j、lomback 则是底层日志框架。

可以通过 slf4j 来调用底层日志框架的接口，进行日志输出，但底层框架也可以独立使用



####  1.1.2 SpringMVC 中使用 log4j

先引入依赖：

```
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-core</artifactId>
    <version>${log4j.version}</version>
</dependency>
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
<dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-api</artifactId>
    <version>${log4j.version}</version>
</dependency>
```

在 web.xml 中设置监听器

```java
<!--由Spring载入的Log4j配置文件位置-->
<context-param>
    <param-name>log4jConfigLocation</param-name>
    <param-value>classpath:resource/log4j.properties</param-value>
</context-param>
<!--Spring log4j Config loader-->
<listener>
    <listener-class>
        org.springframework.web.util.Log4jConfigListener
    </listener-class>
</listener>
```

在 resource 文件夹中增加 log4j.properties ：

```xml
// An highlighted block
# Root logger option
log4j.rootLogger=INFO, WARN, stdout, file

# Redirect log messages to console
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.Target=System.out
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n

# Redirect log messages to a log file
log4j.appender.file=org.apache.log4j.RollingFileAppender
#outputs to Tomcat home
log4j.appender.file.File=E://lincya//Java//tao-parent//tao-manager//tao-manager-web//src//main//resources//logs//myapp.log
log4j.appender.file.MaxFileSize=5MB
log4j.appender.file.MaxBackupIndex=10
log4j.appender.file.layout=org.apache.log4j.PatternLayout
log4j.appender.file.layout.ConversionPattern=%d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n
```



#### 1.1.3 SpringMvc 中使用 logback

##### 1.1.3.1 配置

先添加依赖

```xml
<!-- 日志 -->
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.2.3</version>
</dependency>
<dependency>
    <groupId>org.logback-extensions</groupId>
    <artifactId>logback-ext-spring</artifactId>
    <version>0.1.4</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>1.7.25</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>jcl-over-slf4j</artifactId>
    <version>1.7.25</version>
</dependency>
```

在 resouces 中新增配置文件 logback-spring.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!-- scan="true" 开启自动扫描
     scanPeriod="30 seconds" 设置自动扫描时间 30s一次
-->
<configuration scan="true" scanPeriod="30 seconds">
    <!--  定义日志目录的路径  -->
    <property name="LOG_PATH" value="logs"/>

    <!--定义日志文件的存储地址 勿在 LogBack 的配置中使用相对路径-->
    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>

    <!-- 日志记录器，日期滚动记录 -->
    <appender name="FILEINFO" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <!--   主动创建文件！！！   -->
        <file>${LOG_PATH}/api.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>${LOG_PATH}/info/api-info-%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP">
                <maxFileSize>50MB</maxFileSize>
            </timeBasedFileNamingAndTriggeringPolicy>
        </rollingPolicy>
        <!-- 追加方式记录日志 -->
        <append>true</append>
        <!-- 日志文件的格式 -->
        <encoder class="ch.qos.logback.classic.encoder.PatternLayoutEncoder">
            <pattern>%d{yyyy-MM-dd HH:mm:ss} - %logger{50} %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
        <!-- 此日志文件只记录info级别以上的 -->
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>INFO</level>
        </filter>
    </appender>

    <logger name="org.springframework.aop.aspectj" level="ERROR"/>
    <logger name="org.mongodb" level="ERROR"/>
    <logger name="io.netty" level="ERROR"/>
    <logger name="org.redisson" level="ERROR"/>
    <logger name="org.springframework" level="ERROR"/>
    <logger name="org.tio.client.TioClient" level="ERROR"/>
    <root level="INFO">
        <appender-ref ref="STDOUT" />
        <appender-ref ref="FILEINFO" />
    </root>
</configuration>
```

在 web.xml 中增加监听器

```xml
<context-param>
    <param-name>logbackConfigLocation</param-name>
    <param-value>classpath:resource/logback.xml</param-value>
</context-param>
<listener>
    <listener-class>ch.qos.logback.ext.spring.web.LogbackConfigListener</listener-class>
</listener>
```



##### 1.1.3.2 使用

```
Logger logger = LoggerFactory.getLogger(tbItemController.class);
logger.info("啊啊啊啊来啦");
```



##### 1.1.3.3 结合 lombok 使用

引入 lombok

```xml
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <version>1.16.20</version>
</dependency>
```

在要使用的文件的类上添加注解： @Slf4j

```java
@Controller
@Slf4j
public class tbItemController {

    @Autowired
    private ItemService itemService;

    @RequestMapping("/item/list")
    @ResponseBody
    public Page getItemList(Integer page, Integer rows) {
        log.info("啊啊啊啊来啦");
        return null;
    }
}

```



### 1.2 文件上传

#### 1.2.1 实现文件上传的方式

传统的 java 编写、搭建ftp服务器、搭建 fastdfs 分布式文件服务器

#### 1.2.2 搭建 vsftpd

```
# 下载
yum -y install vsftpd

# 配置用户
useradd ftpuser
passwd ftpuser

# selinux 查看是否关闭/放行，若已经关闭，则略过这步
getsebool -a|grep ftp

# 修改配置文件，关闭匿名模式
vim /etc/vsftpd/vsftpd.conf 
# 找到下面这个，修改为 NO
anonymous_enable=NO
# 开启被动模式，即链接请求由客户端发起
# 在 vsftpd.conf 最后加上：
pasv_min_port=30000
pasv_max_port=30999

# 打开防护墙端口和云服务器的端口
firewall-cmd --zone=public --add-port=30000-30999/tcp --permanent
firewall-cmd --reload

# 设置开机自启动
chkconfig vsftpd on

# 启动 vsftpd
service vsftpd start
```



#### 1.2.3 FastDFS安装

https://www.cnblogs.com/chiangchou/p/fastdfs.html

https://princeyao.blog.csdn.net/article/details/49491085

#####  1.2.3.1 环境准备和安装

###### 环境准备

```
# FastDFS 是基于c语言开发的，需要下载源码编译，需要gcc环境
yum install -y gcc gcc-c++

# 安装libevent
yum -y install libevent

# 安装 libfastcommon，由 FastDFS 官方提供，包含基础库
wget https://github.com/happyfish100/libfastcommon/archive/V1.0.7.tar.gz
tar -zxvf V1.0.7.tar.gz 
mv libfastcommon-1.0.7/ libfastcommon

# 编译
cd libfastcommon
./make.sh
./make.sh install

# 创建软连接，由于库安装在了 /usr/lib64下，但 fastdfs 的程序运行路径为 /usr/lib，故创建软连接
ln -s /usr/lib64/libfastcommon.so /usr/local/lib/libfastcommon.so
ln -s /usr/lib64/libfastcommon.so /usr/lib/libfastcommon.so
ln -s /usr/lib64/libfdfsclient.so /usr/local/lib/libfdfsclient.so
ln -s /usr/lib64/libfdfsclient.so /usr/lib/libfdfsclient.so 
```



###### FastDFS 安装

```
# 下载
wget https://github.com/happyfish100/fastdfs/archive/V5.05.tar.gz
tar -zxvf V5.05.tar.gz 
mv fastdfs-5.05/ fastdfs

# 编译和安装
./make.sh
./make.sh install

# FastDFS 服务脚本设置的 bin 目录是 /usr/local/bin， 但实际命令安装在 /usr/bin/ 下，设置软连接
ln -s /usr/bin/fdfs_trackerd   /usr/local/bin
ln -s /usr/bin/fdfs_storaged   /usr/local/bin
ln -s /usr/bin/stop.sh         /usr/local/bin
ln -s /usr/bin/restart.sh      /usr/local/bin
```



###### FastDFS 安装后的目录和文件

服务脚本

```
/etc/init.d/fdfs_storaged
/etc/init.d/fdfs_tracker
```

配置文件(样例文件)

```
/etc/fdfs/client.conf.sample
/etc/fdfs/storage.conf.sample
/etc/fdfs/tracker.conf.sample
```

命令工具

```
fdfs_appender_test
fdfs_appender_test1
fdfs_append_file
fdfs_crc32
fdfs_delete_file
fdfs_download_file
fdfs_file_info
fdfs_monitor
fdfs_storaged
fdfs_test
fdfs_test1
fdfs_trackerd
fdfs_upload_appender
fdfs_upload_file
stop.sh
restart.sh 
```



##### 1.2.3.2 tracker(跟踪器)配置

###### 配置

```
# 直接复制样例文件进行配置
cd /etc/fdfs
cp tracker.conf.sample tracker.conf
vim tracker.conf
```

修改内容

```
# 配置文件是否不生效，false 为生效
disabled=false
# 提供服务的端口
port=22122
# Tracker 数据和日志目录地址(根目录必须存在,子目录会自动创建)
base_path=/opt/fastdfs/data/tracker
# HTTP 服务端口
http.server_port=80
```

创建对应的存储目录

```
mkdir /opt/fastdfs/data
mkdir /opt/fastdfs/data/tracker
```

打开防火墙端口

```
# 打开防火墙端口
firewall-cmd --zone=public --add-port=22122/tcp --permanent
firewall-cmd --reload 

# 若是云服务器，记得开放安全组
```

启动 tracker

```
# 启动trakcer
service fdfs_trackerd start

# 检查是否启动成功
netstat -unltp|grep fdfs
```

设置开机自启动

```
chkconfig fdfs_trackerd on
```



###### tracker 目录解释

```
${base_path}
  |__data
  |   |__storage_groups.dat：存储分组信息
  |   |__storage_servers.dat：存储服务器列表
  |__logs
  |   |__trackerd.log： tracker server 日志文件 
```



##### 1.2.3.3 storage(存储)配置

###### 配置

```
# 直接复制样例文件进行配置
cd /etc/fdfs
cp storage.conf.sample storage.conf
vim storage.conf
```

修改内容

```
# 配置文件是否不生效，false 为生效
disabled=false 

# 指定此 storage server 所在 组(卷)
group_name=group1

# storage server 服务端口
port=23000

# 心跳间隔时间，单位为秒 (这里是指主动向 tracker server 发送心跳)
heart_beat_interval=30

# Storage 数据和日志目录地址(根目录必须存在，子目录会自动生成)
base_path=/opt/fastdfs/data/storage

# 存放文件时 storage server 支持多个路径。这里配置存放文件的基路径数目，通常只配一个目录。
store_path_count=1

# 逐一配置 store_path_count 个路径，索引号基于 0。
# 如果不配置 store_path0，那它就和 base_path 对应的路径一样。
# 如果没有则创建
store_path0=/usr/local/fdfs_data

# FastDFS 存储文件时，采用了两级目录。这里配置存放文件的目录个数。 
# 如果本参数只为 N（如： 256），那么 storage server 在初次运行时，会在 store_path 下自动创建 N * N 个存放文件的子目录。
subdir_count_per_path=256

# tracker_server 的列表 ，会主动连接 tracker_server
# 有多个 tracker server 时，每个 tracker server 写一行
tracker_server=file.ljzsg.com:22122# 允许系统同步的时间段 (默认是全天) 。一般用于避免高峰同步产生一些问题而设定。sync_start_time=00:00sync_end_time=23:59# 访问端口http.server_port=80
```

创建配置中的存储路径

```
mkdir /usr/local/fdfs_data
mkdir /opt/fastdfs/data/tracker
```

打开防火墙

```
# 打开防火墙端口
firewall-cmd --zone=public --add-port=23000/tcp --permanent
firewall-cmd --reload 

# 若是云服务器，记得开放安全组
```

启动 storage，启动前确保 tracker 已经启动了

```
# 启动 storage
service fdfs_storaged start

# 检查是否启动成功
netstat -unltp|grep fdfs
```

设置开机自启动

```
chkconfig fdfs_storaged on
```



###### 检查 trakcer 和 storage 是否正常通信

```
/usr/bin/fdfs_monitor /etc/fdfs/storage.conf
```

![image-20201201092255019](E:\tmp\笔记\日常纪要.assets\image-20201201092255019.png)



##### 1.2.3.4 文件上传测试

###### 配置

修改客户端配置文件

```
cd /etc/fdfs
cp client.conf.sample client.conf
vim client.conf
```

修改配置文件

```
base_path=/opt/fastdfs/data/client
tracker_server=www.gtom.top:22122
```

创建对应目录

```
mkdir /opt/fastdfs/data/client
```

###### 测试

上传

```
/usr/bin/fdfs_upload_file /etc/fdfs/client.conf 1.jpg
```

![image-20201201092315918](E:\tmp\笔记\日常纪要.assets\image-20201201092315918.png)

配置 nginx 访问

```
location /group1/M00 {
	alias /usr/local/fdfs_data/data;
}

```

访问：

http://xxx.com/group1/M00/00/00/rBDMR1_Eq_aABOWvAAAN43BOJY8640.jpg



##### 1.2.3.5 安装 fastdfs-nginx-module

###### 概念

FastDFS 通过 Tracker 服务器，将文件放在 Storage 服务器存储， 但是同组存储服务器之间需要进行文件复制， 有同步延迟的问题。可能同组 storage 间正在复制文件，但访问的 storage 中还没有下载好用户要访问的文件

fastdfs-nginx-module 可以重定向文件链接到源服务器取文件，避免客户端由于复制延迟导致的文件无法访问错误



###### 配置

先下载模块

```
wget https://github.com/happyfish100/fastdfs-nginx-module/archive/5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip
# 解压
unzip 5e5f3566bbfa57418b5506aaefbe107a42c9fcb1.zip
# 重命名
mv fastdfs-nginx-module-5e5f3566bbfa57418b5506aaefbe107a42c9fcb1  fastdfs-nginx-module-master
```

停止nginx，给nginx增加模块

```
# 停止 nginx
./opt/nginx/sbin/nginx -s stop

# 增加模块
cd /opt/nginx
./configure --add-module=../fastdfs-nginx-module-master/src

# 重新编译安装
make && make install
```

查看模块是否添加成功

```
/opt/nginx/sbin/nginx -V
```

![image-20201201092333529](E:\tmp\笔记\日常纪要.assets\image-20201201092333529.png)

复制 fastdfs-nginx-module 源码中的配置文件到/etc/fdfs 目录， 并修改

```
cd /opt/fastdfs-nginx-module-master/src
cp mod_fastdfs.conf /etc/fdfs/
vim /etc/fdfs/mod_fastdfs.conf
```

修改 mod_fastdfs.conf

```
# 连接超时时间connect_timeout=10
# Tracker Server
tracker_server=xxx.com:22122
# StorageServer 默认端口
storage_server_port=23000

# 如果文件ID的uri中包含/group**，则要设置为true
url_have_group_name = true

# Storage 配置的store_path0路径，必须和storage.conf中的一致
store_path0=/usr/local/fdfs_data
```

复制配置文件

```
cd /opt/fastdfs/conf
cp http.conf mime.types /etc/fdfs/
```







##### 1.2.3.6 Java代码测试

###### 引入依赖

```
<!-- 文件上传 -->
<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.3</version>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-pool2</artifactId>
    <version>2.4.2</version>
</dependency>
<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
    <version>1.6</version>
</dependency>
<dependency>
    <groupId>net.oschina.zcx7878</groupId>
    <artifactId>fastdfs-client-java</artifactId>
    <version>1.27.0.0</version>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.3.2</version>
</dependency>
<!--   io流  -->
<dependency>
    <groupId>commons-io</groupId>
    <artifactId>commons-io</artifactId>
    <version>2.4</version>
</dependency>
```

###### 配置文件 fastdfs.properties

```
#################### FastDFS-Client Start ####################
# 最大连接数 并发量较大的话可加大该连接数
max_storage_connection=8

## fastdfs为前缀的是FastDFS的配置
fastdfs.connect_timeout_in_seconds=10
fastdfs.network_timeout_in_seconds=30

fastdfs.charset=UTF-8

# token 防盗链功能
fastdfs.http_anti_steal_token=false
# 密钥
fastdfs.http_secret_key=HandFastDFSToken

# TrackerServer port
fastdfs.http_tracker_http_port=80

## Tracker Server, if more than one, separate with ","
# fastdfs.tracker_servers=10.0.11.201:22122,10.0.11.202:22122,10.0.11.203:22122
# fastdfs.tracker_servers=${tracker_server_addr}:22122
fastdfs.tracker_servers=www.gtom.top:22122
#################### FastDFS-Client End ####################
```



###### 相关类

注意： 在 TrackerServerPool 类中指定了要获取的配置文件路径，根据实际情况更改

```java
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.lang3.StringUtils;
import org.csource.common.MyException;
import org.csource.common.NameValuePair;
import org.csource.fastdfs.FileInfo;
import org.csource.fastdfs.ProtoCommon;
import org.csource.fastdfs.StorageClient1;
import org.csource.fastdfs.TrackerServer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.web.multipart.MultipartFile;

import javax.servlet.http.HttpServletResponse;
import java.io.ByteArrayInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.security.NoSuchAlgorithmException;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * FastDFS Java API. 文件上传下载主类.
 * <p>
 *
 * @name FastDFSClient
 */
public class FastDFSClient {
    /**
     * 路径分隔符
     */
    public static final String SEPARATOR = "/";
    /**
     * Point
     */
    public static final String POINT = ".";
    /**
     * ContentType
     */
    public static final Map<String, String> EXT_MAPS = new HashMap<>();

    /**
     * org.slf4j.Logger
     */
    private static Logger logger = LoggerFactory.getLogger(FastDFSClient.class);
    /**
     * 文件名称Key
     */
    private static final String FILENAME = "filename";
    /**
     * 文件最大的大小
     */
    private int maxFileSize = 100 * 1000 * 1000;

    public FastDFSClient() {
        initExt();
    }

    private void initExt() {
        // image
        EXT_MAPS.put("png", "image/png");
        EXT_MAPS.put("gif", "image/gif");
        EXT_MAPS.put("bmp", "image/bmp");
        EXT_MAPS.put("ico", "image/x-ico");
        EXT_MAPS.put("jpeg", "image/jpeg");
        EXT_MAPS.put("jpg", "image/jpeg");
        // 压缩文件
        EXT_MAPS.put("zip", "application/zip");
        EXT_MAPS.put("rar", "application/x-rar");
        // doc
        EXT_MAPS.put("pdf", "application/pdf");
        EXT_MAPS.put("ppt", "application/vnd.ms-powerpoint");
        EXT_MAPS.put("xls", "application/vnd.ms-excel");
        EXT_MAPS.put("xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet");
        EXT_MAPS.put("pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation");
        EXT_MAPS.put("doc", "application/msword");
        EXT_MAPS.put("doc", "application/wps-office.doc");
        EXT_MAPS.put("docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document");
        EXT_MAPS.put("txt", "text/plain");
        // 音频
        EXT_MAPS.put("mp4", "video/mp4");
        EXT_MAPS.put("flv", "video/x-flv");
    }

    /**
     * MultipartFile 上传文件
     *
     * @param file MultipartFile
     * @return 返回上传成功后的文件路径
     */
    public String uploadFileWithMultipart(MultipartFile file) throws FastDFSException {
        return upload(file, null);
    }

    /**
     * MultipartFile 上传文件
     *
     * @param file         MultipartFile
     * @param descriptions 文件描述
     * @return 返回上传成功后的文件路径
     */
    public String uploadFileWithMultipart(MultipartFile file, Map<String, String> descriptions) throws FastDFSException {
        return upload(file, descriptions);
    }

    /**
     * 根据指定的路径上传文件
     *
     * @param filepath 文件路径
     * @return 返回上传成功后的文件路径
     */
    public String uploadFileWithFilepath(String filepath) throws FastDFSException {
        return upload(filepath, null);
    }

    /**
     * 根据指定的路径上传文件
     *
     * @param filepath     文件路径
     * @param descriptions 文件描述
     * @return 返回上传成功后的文件路径
     */
    public String uploadFileWithFilepath(String filepath, Map<String, String> descriptions) throws FastDFSException {
        return upload(filepath, descriptions);
    }

    /**
     * 上传base64文件
     *
     * @param base64 文件base64
     * @return 返回上传成功后的文件路径
     */
    public String uploadFileWithBase64(String base64) throws FastDFSException {
        return upload(base64, null, null);
    }

    /**
     * 上传base64文件
     *
     * @param base64   文件base64
     * @param filename 文件名
     * @return 返回上传成功后的文件路径
     */
    public String uploadFileWithBase64(String base64, String filename) throws FastDFSException {
        return upload(base64, filename, null);
    }

    /**
     * 上传base64文件
     *
     * @param base64       文件base64
     * @param filename     文件名
     * @param descriptions 文件描述信息
     * @return 返回上传成功后的文件路径
     */
    public String uploadFileWithBase64(String base64, String filename, Map<String, String> descriptions) throws FastDFSException {
        return upload(base64, filename, descriptions);
    }

    /**
     * 使用 MultipartFile 上传
     *
     * @param file         MultipartFile
     * @param descriptions 文件描述信息
     * @return 文件路径
     * @throws FastDFSException file为空则抛出异常
     */
    public String upload(MultipartFile file, Map<String, String> descriptions) throws FastDFSException {
        if (file == null || file.isEmpty()) {
            throw new FastDFSException(ErrorCode.FILE_ISNULL.CODE, ErrorCode.FILE_ISNULL.MESSAGE);
        }
        String path = null;
        try {
            path = upload(file.getInputStream(), file.getOriginalFilename(), descriptions);
        } catch (IOException e) {
            e.printStackTrace();
            throw new FastDFSException(ErrorCode.FILE_ISNULL.CODE, ErrorCode.FILE_ISNULL.MESSAGE);
        }
        return path;
    }

    /**
     * 根据指定的路径上传
     *
     * @param filepath     文件路径
     * @param descriptions 文件描述
     * @return 文件路径
     * @throws FastDFSException 文件路径为空则抛出异常
     */
    public String upload(String filepath, Map<String, String> descriptions) throws FastDFSException {
        if (StringUtils.isBlank(filepath)) {
            throw new FastDFSException(ErrorCode.FILE_PATH_ISNULL.CODE, ErrorCode.FILE_PATH_ISNULL.MESSAGE);
        }
        File file = new File(filepath);
        String path = null;
        try {
            InputStream is = new FileInputStream(file);
            // 获取文件名
            filepath = toLocal(filepath);
            String filename = filepath.substring(filepath.lastIndexOf("/") + 1);

            path = upload(is, filename, descriptions);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
            throw new FastDFSException(ErrorCode.FILE_NOT_EXIST.CODE, ErrorCode.FILE_NOT_EXIST.MESSAGE);
        }

        return path;
    }

    /**
     * 上传base64文件
     *
     * @param base64
     * @param filename     文件名
     * @param descriptions 文件描述信息
     * @return 文件路径
     * @throws FastDFSException base64为空则抛出异常
     */
    public String upload(String base64, String filename, Map<String, String> descriptions) throws FastDFSException {
        if (StringUtils.isBlank(base64)) {
            throw new FastDFSException(ErrorCode.FILE_ISNULL.CODE, ErrorCode.FILE_ISNULL.MESSAGE);
        }
        return upload(new ByteArrayInputStream(Base64.decodeBase64(base64)), filename, descriptions);
    }

    /**
     * 上传通用方法
     *
     * @param is           文件输入流
     * @param filename     文件名
     * @param descriptions 文件描述信息
     * @return 组名+文件路径，如：group1/M00/00/00/wKgz6lnduTeAMdrcAAEoRmXZPp870.jpeg
     * @throws FastDFSException
     */
    public String upload(InputStream is, String filename, Map<String, String> descriptions) throws FastDFSException {
        if (is == null) {
            throw new FastDFSException(ErrorCode.FILE_ISNULL.CODE, ErrorCode.FILE_ISNULL.MESSAGE);
        }

        try {
            if (is.available() > maxFileSize) {
                throw new FastDFSException(ErrorCode.FILE_OUT_SIZE.CODE, ErrorCode.FILE_OUT_SIZE.MESSAGE);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

        filename = toLocal(filename);
        // 返回路径
        String path = null;
        // 文件描述
        NameValuePair[] nvps = null;
        List<NameValuePair> nvpsList = new ArrayList<>();
        // 文件名后缀
        String suffix = getFilenameSuffix(filename);

        // 文件名
        if (StringUtils.isNotBlank(filename)) {
            nvpsList.add(new NameValuePair(FILENAME, filename));
        }
        // 描述信息
        if (descriptions != null && descriptions.size() > 0) {
            Set<String> keys = descriptions.keySet();
            for(String key : keys) {
             String value = descriptions.get(key);
                nvpsList.add(new NameValuePair(key, value));
            }
        }
        if (nvpsList.size() > 0) {
            nvps = new NameValuePair[nvpsList.size()];
            nvpsList.toArray(nvps);
        }

        TrackerServer trackerServer = TrackerServerPool.borrowObject();
        StorageClient1 storageClient = new StorageClient1(trackerServer, null);
        try {
            // 读取流
            byte[] fileBuff = new byte[is.available()];
            is.read(fileBuff, 0, fileBuff.length);

            // 上传
            path = storageClient.upload_file1(fileBuff, suffix, nvps);

            if (StringUtils.isBlank(path)) {
                throw new FastDFSException(ErrorCode.FILE_UPLOAD_FAILED.CODE, ErrorCode.FILE_UPLOAD_FAILED.MESSAGE);
            }

            if (logger.isDebugEnabled()) {
                logger.debug("upload file success, return path is {}", path);
            }
        } catch (IOException e) {
            e.printStackTrace();
            throw new FastDFSException(ErrorCode.FILE_UPLOAD_FAILED.CODE, ErrorCode.FILE_UPLOAD_FAILED.MESSAGE);
        } catch (MyException e) {
            e.printStackTrace();
            throw new FastDFSException(ErrorCode.FILE_UPLOAD_FAILED.CODE, ErrorCode.FILE_UPLOAD_FAILED.MESSAGE);
        } finally {
            // 关闭流
            if (is != null) {
                try {
                    is.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        // 返还对象
        TrackerServerPool.returnObject(trackerServer);

        return path;
    }

    /**
     * 以附件形式下载文件
     *
     * @param filepath 文件路径
     * @param response
     */
    public void downloadFile(String filepath, HttpServletResponse response) throws FastDFSException {
        download(filepath, null, null, response);
    }

    /**
     * 下载文件 输出文件
     *
     * @param filepath 文件路径
     * @param os       输出流
     */
    public void downloadFile(String filepath, OutputStream os) throws FastDFSException {
        download(filepath, null, os, null);
    }

    /**
     * 以附件形式下载文件 可以指定文件名称.
     *
     * @param filepath 文件路径
     * @param filename 文件名称
     * @param response HttpServletResponse
     */
    public void downloadFile(String filepath, String filename, HttpServletResponse response) throws FastDFSException {
        download(filepath, filename, null, response);
    }

    /**
     * 下载文件
     *
     * @param filepath 文件路径
     * @param filename 文件名称
     * @param os       输出流
     * @param response HttpServletResponse
     */
    public void download(String filepath, String filename, OutputStream os, HttpServletResponse response) throws FastDFSException {
        if (StringUtils.isBlank(filepath)) {
            throw new FastDFSException(ErrorCode.FILE_PATH_ISNULL.CODE, ErrorCode.FILE_PATH_ISNULL.MESSAGE);
        }

        filepath = toLocal(filepath);
        // 文件名
        if (StringUtils.isBlank(filename)) {
            filename = getOriginalFilename(filepath);
        }
        String contentType = EXT_MAPS.get(getFilenameSuffix(filename));

        if (logger.isDebugEnabled()) {
            logger.debug("download file, filepath = {}, filename = {}", filepath, filename);
        }

        TrackerServer trackerServer = TrackerServerPool.borrowObject();
        StorageClient1 storageClient = new StorageClient1(trackerServer, null);
        InputStream is = null;
        try {
            // 下载
            byte[] fileByte = storageClient.download_file1(filepath);

            if (fileByte == null) {
                throw new FastDFSException(ErrorCode.FILE_NOT_EXIST.CODE, ErrorCode.FILE_NOT_EXIST.MESSAGE);
            }

            if (response != null) {
                os = response.getOutputStream();

                // 设置响应头
                if (StringUtils.isNotBlank(contentType)) {
                    // 文件编码 处理文件名中的 '+'、' ' 特殊字符
                    String encoderName = URLEncoder.encode(filename, "UTF-8").replace("+", "%20").replace("%2B", "+");
                    response.setHeader("Content-Disposition", "attachment;filename=\"" + encoderName + "\"");
                    response.setContentType(contentType + ";charset=UTF-8");
                    response.setHeader("Accept-Ranges", "bytes");
                }
            }

            is = new ByteArrayInputStream(fileByte);
            byte[] buffer = new byte[1024 * 5];
            int len = 0;
            while ((len = is.read(buffer)) > 0) {
                os.write(buffer, 0, len);
            }
            os.flush();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (MyException e) {
            e.printStackTrace();
            throw new FastDFSException(ErrorCode.FILE_DOWNLOAD_FAILED.CODE, ErrorCode.FILE_DOWNLOAD_FAILED.MESSAGE);
        } finally {
            // 关闭流
            try {
                if (is != null) {
                    is.close();
                }
                if (os != null) {
                    os.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        // 返还对象
        TrackerServerPool.returnObject(trackerServer);
    }

    /**
     * 下载文件
     *
     * @param filepath 文件路径
     * @return 返回文件字节
     * @throws FastDFSException
     */
    public byte[] download(String filepath) throws FastDFSException {
        if (StringUtils.isBlank(filepath)) {
            throw new FastDFSException(ErrorCode.FILE_PATH_ISNULL.CODE, ErrorCode.FILE_PATH_ISNULL.MESSAGE);
        }

        TrackerServer trackerServer = TrackerServerPool.borrowObject();
        StorageClient1 storageClient = new StorageClient1(trackerServer, null);
        InputStream is = null;
        byte[] fileByte = null;
        try {
            fileByte = storageClient.download_file1(filepath);

            if (fileByte == null) {
                throw new FastDFSException(ErrorCode.FILE_NOT_EXIST.CODE, ErrorCode.FILE_NOT_EXIST.MESSAGE);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (MyException e) {
            e.printStackTrace();
            throw new FastDFSException(ErrorCode.FILE_DOWNLOAD_FAILED.CODE, ErrorCode.FILE_DOWNLOAD_FAILED.MESSAGE);
        }
        // 返还对象
        TrackerServerPool.returnObject(trackerServer);

        return fileByte;
    }

    /**
     * 删除文件
     *
     * @param filepath 文件路径
     * @return 删除成功返回 0, 失败返回其它
     */
    public int deleteFile(String filepath) throws FastDFSException {
        if (StringUtils.isBlank(filepath)) {
            throw new FastDFSException(ErrorCode.FILE_PATH_ISNULL.CODE, ErrorCode.FILE_PATH_ISNULL.MESSAGE);
        }

        TrackerServer trackerServer = TrackerServerPool.borrowObject();
        StorageClient1 storageClient = new StorageClient1(trackerServer, null);
        int success = 0;
        try {
            success = storageClient.delete_file1(filepath);
            if (success != 0) {
                throw new FastDFSException(ErrorCode.FILE_DELETE_FAILED.CODE, ErrorCode.FILE_DELETE_FAILED.MESSAGE);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } catch (MyException e) {
            e.printStackTrace();
            throw new FastDFSException(ErrorCode.FILE_DELETE_FAILED.CODE, ErrorCode.FILE_DELETE_FAILED.MESSAGE);
        }
        // 返还对象
        TrackerServerPool.returnObject(trackerServer);

        return success;
    }

    /**
     * 获取文件信息
     *
     * @param filepath 文件路径
     * @return 文件信息
     *
     * <pre>
     *  {<br>
     *      "SourceIpAddr": 源IP <br>
     *      "FileSize": 文件大小 <br>
     *      "CreateTime": 创建时间 <br>
     *      "CRC32": 签名 <br>
     *  }  <br>
     * </pre>
     */
    public Map<String, Object> getFileInfo(String filepath) throws FastDFSException {
        TrackerServer trackerServer = TrackerServerPool.borrowObject();
        StorageClient1 storageClient = new StorageClient1(trackerServer, null);
        FileInfo fileInfo = null;
        try {
            fileInfo = storageClient.get_file_info1(filepath);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (MyException e) {
            e.printStackTrace();
        }
        // 返还对象
        TrackerServerPool.returnObject(trackerServer);

        Map<String, Object> infoMap = new HashMap<>(4);

        infoMap.put("SourceIpAddr", fileInfo.getSourceIpAddr());
        infoMap.put("FileSize", fileInfo.getFileSize());
        infoMap.put("CreateTime", new SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(fileInfo.getCreateTimestamp()));
        infoMap.put("CRC32", fileInfo.getCrc32());

        return infoMap;
    }

    /**
     * 获取文件描述信息
     *
     * @param filepath 文件路径
     * @return 文件描述信息
     */
    public Map<String, Object> getFileDescriptions(String filepath) throws FastDFSException {
        TrackerServer trackerServer = TrackerServerPool.borrowObject();
        StorageClient1 storageClient = new StorageClient1(trackerServer, null);
        NameValuePair[] nvps = null;
        try {
            nvps = storageClient.get_metadata1(filepath);
        } catch (IOException e) {
            e.printStackTrace();
        } catch (MyException e) {
            e.printStackTrace();
        }
        // 返还对象
        TrackerServerPool.returnObject(trackerServer);

        Map<String, Object> infoMap = null;

        if (nvps != null && nvps.length > 0) {
            infoMap = new HashMap<>(nvps.length);

            for (NameValuePair nvp : nvps) {
                infoMap.put(nvp.getName(), nvp.getValue());
            }
        }

        return infoMap;
    }

    /**
     * 获取源文件的文件名称
     *
     * @param filepath 文件路径
     * @return 文件名称
     */
    public String getOriginalFilename(String filepath) throws FastDFSException {
        Map<String, Object> descriptions = getFileDescriptions(filepath);
        if (descriptions.get(FILENAME) != null) {
            return (String) descriptions.get(FILENAME);
        }
        return null;
    }

    /**
     * 获取文件名称的后缀
     *
     * @param filename 文件名 或 文件路径
     * @return 文件后缀
     */
    public static String getFilenameSuffix(String filename) {
        String suffix = null;
        String originalFilename = filename;
        if (StringUtils.isNotBlank(filename)) {
            if (filename.contains(SEPARATOR)) {
                filename = filename.substring(filename.lastIndexOf(SEPARATOR) + 1);
            }
            if (filename.contains(POINT)) {
                suffix = filename.substring(filename.lastIndexOf(POINT) + 1);
            } else {
                if (logger.isErrorEnabled()) {
                    logger.error("filename error without suffix : {}", originalFilename);
                }
            }
        }
        return suffix;
    }

    /**
     * 转换路径中的 '\' 为 '/' <br>
     * 并把文件后缀转为小写
     *
     * @param path 路径
     * @return
     */
    public static String toLocal(String path) {
        if (StringUtils.isNotBlank(path)) {
            path = path.replaceAll("\\\\", SEPARATOR);

            if (path.contains(POINT)) {
                String pre = path.substring(0, path.lastIndexOf(POINT) + 1);
                String suffix = path.substring(path.lastIndexOf(POINT) + 1).toLowerCase();
                path = pre + suffix;
            }
        }
        return path;
    }

    /**
     * 获取FastDFS文件的名称，如：M00/00/00/wKgzgFnkTPyAIAUGAAEoRmXZPp876.jpeg
     *
     * @param fileId 包含组名和文件名，如：group1/M00/00/00/wKgzgFnkTPyAIAUGAAEoRmXZPp876.jpeg
     * @return FastDFS 返回的文件名：M00/00/00/wKgzgFnkTPyAIAUGAAEoRmXZPp876.jpeg
     */
    public static String getFilename(String fileId) {
        String[] results = new String[2];
        StorageClient1.split_file_id(fileId, results);

        return results[1];
    }

    /**
     * 获取访问服务器的token，拼接到地址后面
     *
     * @param filepath      文件路径 group1/M00/00/00/wKgzgFnkTPyAIAUGAAEoRmXZPp876.jpeg
     * @param httpSecretKey 秘钥
     * @return 返回token，如： token=078d370098b03e9020b82c829c205e1f&ts=1508141521
     */
    public static String getToken(String filepath, String httpSecretKey) {
        // unix seconds
        int ts = (int) Instant.now().getEpochSecond();
        // token
        String token = "null";
        try {
            token = ProtoCommon.getToken(getFilename(filepath), ts, httpSecretKey);
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (MyException e) {
            e.printStackTrace();
        }

        StringBuilder sb = new StringBuilder();
        sb.append("token=").append(token);
        sb.append("&ts=").append(ts);

        return sb.toString();
    }

    public String getFileContentType(String filePath) {
        return EXT_MAPS.get(getFilenameSuffix(filePath));
    }

    /**
     * @return the max file size
     */
    public int getMaxFileSize() {
        return maxFileSize;
    }

    /**
     * Set max file size, default 100M
     *
     * @param maxFileSize the max file size
     */
    public void setMaxFileSize(int maxFileSize) {
        this.maxFileSize = maxFileSize;
    }
}
```

```java
/**
 * FastDFS 上传下载时可能出现的一些异常信息
 * <p>
 * @name FastDFSException
 */
public class FastDFSException extends Exception {

    /**
     * 错误码
     */
    private String code;

    /**
     * 错误消息
     */
    private String message;

    public FastDFSException(){}

    public FastDFSException(String code, String message) {
        this.code = code;
        this.message = message;
    }


    public String getCode() {
        return code;
    }

    public void setCode(String code) {
        this.code = code;
    }

    @Override
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
```

```java
import org.apache.commons.pool2.BasePooledObjectFactory;
import org.apache.commons.pool2.PooledObject;
import org.apache.commons.pool2.impl.DefaultPooledObject;
import org.csource.fastdfs.TrackerClient;
import org.csource.fastdfs.TrackerServer;

/**
 * TrackerServer 工厂类，创建对象池需要 BasePooledObjectFactory 对象或子类.
 */
public class TrackerServerFactory extends BasePooledObjectFactory<TrackerServer> {

    @Override
    public TrackerServer create() throws Exception {
        // TrackerClient
        TrackerClient trackerClient = new TrackerClient();
        // TrackerServer
        TrackerServer trackerServer = trackerClient.getConnection();

        return trackerServer;
    }

    @Override
    public PooledObject<TrackerServer> wrap(TrackerServer trackerServer) {
        return new DefaultPooledObject<TrackerServer>(trackerServer);
    }
}

```

```java
import org.apache.commons.pool2.impl.GenericObjectPool;
import org.apache.commons.pool2.impl.GenericObjectPoolConfig;
import org.csource.common.MyException;
import org.csource.fastdfs.ClientGlobal;
import org.csource.fastdfs.TrackerServer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;

import java.io.IOException;

/**
 * TrackerServer 对象池
 * <p>
 */
public class TrackerServerPool {
    /**
     * org.slf4j.Logger
     */
    private static Logger logger = LoggerFactory.getLogger(TrackerServerPool.class);

    /**
     * TrackerServer 配置文件路径
     */
    private static final String FASTDFS_CONFIG_PATH = "fastdfs.properties";

    /**
     * 最大连接数 default 8.
     */
    @Value("${fastdfs.max_storage_connection}")
    private static int maxStorageConnection;

    /**
     * TrackerServer 对象池.
     * GenericObjectPool 没有无参构造
     */
    private static GenericObjectPool<TrackerServer> trackerServerPool;

    private TrackerServerPool(){};

    private static synchronized GenericObjectPool<TrackerServer> getObjectPool(){
        if(trackerServerPool == null){
            try {
                // 加载配置文件
                ClientGlobal.initByProperties(FASTDFS_CONFIG_PATH);
            } catch (IOException e) {
                e.printStackTrace();
            } catch (MyException e) {
                e.printStackTrace();
            }

            if(logger.isDebugEnabled()){
                logger.debug("ClientGlobal configInfo: {}", ClientGlobal.configInfo());
            }

            // Pool配置
            GenericObjectPoolConfig poolConfig = new GenericObjectPoolConfig();
            poolConfig.setMinIdle(2);
            if(maxStorageConnection > 0){
                poolConfig.setMaxTotal(maxStorageConnection);
            }

            trackerServerPool = new GenericObjectPool<>(new TrackerServerFactory(), poolConfig);
        }
        return trackerServerPool;
    }

    /**
     * 获取 TrackerServer
     * @return TrackerServer
     * @throws FastDFSException
     */
    public static TrackerServer borrowObject() throws FastDFSException {
        TrackerServer trackerServer = null;
        try {
            trackerServer = getObjectPool().borrowObject();
        } catch (Exception e) {
            e.printStackTrace();
            if(e instanceof FastDFSException){
                throw (FastDFSException) e;
            }
        }
        return trackerServer;
    }

    /**
     * 回收 TrackerServer
     * @param trackerServer 需要回收的 TrackerServer
     */
    public static void returnObject(TrackerServer trackerServer){

        getObjectPool().returnObject(trackerServer);
    }
}
```

```java
/**
 * <p>
 * @name FastDFSErrorCode
 */
public enum ErrorCode {

    FILE_PATH_ISNULL("error.fastdfs.file_path_isnull", "文件路径为空"),

    FILE_ISNULL("error.fastdfs.file_isnull", "文件为空"),

    FILE_UPLOAD_FAILED("error.fastdfs.file_upload_failed", "文件上传失败"),

    FILE_NOT_EXIST("error.fastdfs.file_not_exist", "文件不存在"),

    FILE_DOWNLOAD_FAILED("error.fastdfs.file_download_failed", "文件下载失败"),

    FILE_DELETE_FAILED("error.fastdfs.file_delete_failed", "删除文件失败"),

    FILE_SERVER_CONNECTION_FAILED("error.fastdfs.file_server_connection_failed", "文件服务器连接失败"),

    FILE_OUT_SIZE("error.fastdfs.file_server_connection_failed", "文件超过大小"),

    FILE_TYPE_ERROR_IMAGE("error.file.type.image", "图片类型错误"),

    FILE_TYPE_ERROR_DOC("error.file.type.doc", "文档类型错误"),

    FILE_TYPE_ERROR_VIDEO("error.file.type.video", "音频类型错误"),

    FILE_TYPE_ERROR_COMPRESS("error.file.type.compress", "压缩文件类型错误");


    public String CODE;

    public String MESSAGE;

    ErrorCode(String CODE, String MESSAGE){
        this.CODE = CODE;
        this.MESSAGE = MESSAGE;
    }
}
```





###### 参考

https://github.com/happyfish100/fastdfs-client-java

https://github.com/bojiangzhou/lyyzoo-fastdfs-java

![image-20201201092349218](E:\tmp\笔记\日常纪要.assets\image-20201201092349218.png)

![image-20201201092409442](E:\tmp\笔记\日常纪要.assets\image-20201201092409442.png)







### 1.3 JSONP

#### 1.3.1 概念

由于前端跨域的限制，导致存在跨域请求静态资源被拦截的情况，可以使用 jsonp 来解决

jsonp 实际是通过 js 脚本回调的方式，通过引入外部的 js 代码回调本地代码，实现数据的访问



#### 1.3.2 使用

前端使用 jsonp，暂不描述

**后端：**

写好前端的要调用的方法，方法参数中包含了要传递的数据，返回给前端。

```
category.getDataService({"data":[{"u":"/products/1.html" xxxxxxxxxxxx |T恤","/products/787.html|POLO衫","/products/788.html|针织衫","/products/7/领带夹"]}]}]})
```



### 1.4 树形菜单设计

#### 1.4.1 数据库设计

**将**菜单栏目通过 parent_id 关联起来，由于 service 层是通过递归实现树状菜单的组合的，故给 parent_id 加上索引。

```
create table menu_cat
(
    id         bigint auto_increment comment '类目ID'
        primary key,
    parent_id  bigint               null comment '父类目ID=0时，代表的是一级的类目',
    name       varchar(50)          null comment '类目名称',
    status     int        default 1 null comment '状态。可选值:1(正常),2(删除)',
    sort_order int                  null comment '排列序号，表示同级类目的展现次序，如数值相等则按名称次序排列。取值范围:大于零的整数',
    is_parent  tinyint(1) default 1 null comment '该类目是否为父类目，1为true，0为false',
    created    datetime             null comment '创建时间',
    updated    datetime             null comment '创建时间'
) comment '导航栏目' charset = utf8;

create index parent_id
    on menu_cat (parent_id);

create index sort_order
    on menu_cat (sort_order);
```



#### 1.4.2 Java 代码处理

**service 层**

```java
@Service
public class MenuItemServiceImpl implements MenuItemService {

    @Autowired
    private MenuItemMapper menuItemMapper;

    @Override
    public CatResult getItemCatTree() {
        CatResult result = new CatResult();
        result.setData(makeCatTree(0));
        return result;
    }

    // 递归函数，构造菜单树
    private List<?> makeCatTree(long parentId) {
        List resultList = new ArrayList();
        // 先查询出同一个父亲的孩子节点
        List<TbItemCat> lists = menuItemMapper.getCatList(parentId);
        // 限制获取的数量
        int count = 0;
        for(TbItemCat tbItemCat : lists) {
            // 如果是父节点，则会调用递归函数
            // 具体填入的内如根据实际情况修改
            if (tbItemCat.getIsParent()) {
                CatNode node = new CatNode();
                node.setUrl("/products/" + tbItemCat.getId() + ".html");
                if (parentId == 0) {
                    node.setName("<a href='"+node.getUrl()+"'>"+tbItemCat.getName()+"</a>");
                } else {
                    node.setName(tbItemCat.getName());
                }
                // 由于是父节点，则递归获取子节点内容
                node.setItems(makeCatTree(tbItemCat.getId()));
                resultList.add(node);
            } else {
                String node = "/products/"+tbItemCat.getId()+".html|" + tbItemCat.getName();
                resultList.add(node);
            }
            count++;

            // 最外层循环，只取14条记录
            if(parentId == 0 && count >= 14) {
                break;
            }
        }
        return resultList;
    }
}
```

**controller 层**

这里使用 jsonp 返回给前端

```
// springmvc 4.1 以前
@RequestMapping(value="/list")
@ResponseBody
public String getItemCatList(String callback) {
    CatResult result = itemCatService.getItemCatTree();
    //判断是否是jsonp调用
    if (StringUtils.isBlank(callback)) {
        return JsonUtils.objectToJson(result);
    }
    return callback + "(" + JsonUtils.objectToJson(result) + ");";
}

----------------------------------------------------------------------------------

// springmvc 4.1及之后
@RequestMapping(value="/list")
@ResponseBody
public Object getItemCatList(String callback) {
    CatResult result = itemCatService.getItemCatTree();
    MappingJacksonValue mappingJacksonValue = new MappingJacksonValue(result);
    mappingJacksonValue.setJsonpFunction(callback);
    return mappingJacksonValue;
}
```

**JsonUtils.java 工具类**

```
public class JsonUtils {

    // 定义jackson对象
    private static final ObjectMapper MAPPER = new ObjectMapper();

    /**
     * 将对象转换成json字符串。
     * <p>Title: pojoToJson</p>
     * <p>Description: </p>
     * @param data
     * @return
     */
    public static String objectToJson(Object data) {
    	try {
			String string = MAPPER.writeValueAsString(data);
			return string;
		} catch (JsonProcessingException e) {
			e.printStackTrace();
		}
    	return null;
    }
    
    /**
     * 将json结果集转化为对象
     * 
     * @param jsonData json数据
     * @param clazz 对象中的object类型
     * @return
     */
    public static <T> T jsonToPojo(String jsonData, Class<T> beanType) {
        try {
            T t = MAPPER.readValue(jsonData, beanType);
            return t;
        } catch (Exception e) {
        	e.printStackTrace();
        }
        return null;
    }
    
    /**
     * 将json数据转换成pojo对象list
     * <p>Title: jsonToList</p>
     * <p>Description: </p>
     * @param jsonData
     * @param beanType
     * @return
     */
    public static <T>List<T> jsonToList(String jsonData, Class<T> beanType) {
    	JavaType javaType = MAPPER.getTypeFactory().constructParametricType(List.class, beanType);
    	try {
    		List<T> list = MAPPER.readValue(jsonData, javaType);
    		return list;
		} catch (Exception e) {
			e.printStackTrace();
		}
    	return null;
    }
}

```



### 1.5 通用返回类

定义一个服务器与客户端的通讯类

```java
public class R {
    // 定义jackson对象
    private static final ObjectMapper MAPPER = new ObjectMapper();
    // 响应状态码
    private int code;
    // 响应消息
    private String message;
    // 响应数据
    private Object data;

    public R(String msg) {
        this.code = CodeConstant.OK;
        this.message = msg;
        this.data = null;
    }

    public R(Object data) {
        this.code = CodeConstant.OK;
        this.message = "";
        this.data = data;
    }

    public R(int code, String message, Object data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }

    public static R build(Integer status, String msg, Object data) {
        return new R(status, msg, data);
    }

    public static R success() {
        return new R(null);
    }

    public static R success(String sucMsg) {
        return new R(sucMsg);
    }

    public static R success(Object data) {
        return new R(data);
    }

    public static R error(String errorMsg) {
        return new R(CodeConstant.ERROR, errorMsg, null);
    }

    public static R error(int code, String errorMsg) {
        return new R(code, errorMsg, null);
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }


    /**
     * Object是集合转化
     *
     * @param jsonData json数据
     * @param clazz 集合中的类型
     * @return
     */
    public static R formatToList(String jsonData, Class<?> clazz) {
        try {
            JsonNode jsonNode = MAPPER.readTree(jsonData);
            JsonNode data = jsonNode.get("data");
            Object obj = null;
            if (data.isArray() && data.size() > 0) {
                obj = MAPPER.readValue(data.traverse(),
                        MAPPER.getTypeFactory().constructCollectionType(List.class, clazz));
            }
            return build(jsonNode.get("status").intValue(), jsonNode.get("msg").asText(), obj);
        } catch (Exception e) {
            return null;
        }
    }

    @Override
    public String toString() {
        return "R{" +
                "code=" + code +
                ", message='" + message + '\'' +
                ", data=" + data.toString() +
                '}';
    }
}
```



### 1.6 生成验证码

##### 验证码工具类

```java
package com.tom.shirospringboot.utils;


import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.util.Arrays;
import java.util.Random;

/**
 *@创建人  cx
 *@创建时间  2018/11/27 17:36
 *@描述   验证码生成
 */
public class VerifyCodeUtils{

    //使用到Algerian字体，系统里没有的话需要安装字体，字体只显示大写，去掉了1,0,i,o几个容易混淆的字符
    public static final String VERIFY_CODES = "23456789ABCDEFGHJKLMNPQRSTUVWXYZ";
    private static Random random = new Random();


    /**
     * 使用系统默认字符源生成验证码
     * @param verifySize    验证码长度
     * @return
     */
    public static String generateVerifyCode(int verifySize){
        return generateVerifyCode(verifySize, VERIFY_CODES);
    }
    /**
     * 使用指定源生成验证码
     * @param verifySize    验证码长度
     * @param sources   验证码字符源
     * @return
     */
    public static String generateVerifyCode(int verifySize, String sources){
        if(sources == null || sources.length() == 0){
            sources = VERIFY_CODES;
        }
        int codesLen = sources.length();
        Random rand = new Random(System.currentTimeMillis());
        StringBuilder verifyCode = new StringBuilder(verifySize);
        for(int i = 0; i < verifySize; i++){
            verifyCode.append(sources.charAt(rand.nextInt(codesLen-1)));
        }
        return verifyCode.toString();
    }

    /**
     * 生成随机验证码文件,并返回验证码值
     * @param w
     * @param h
     * @param outputFile
     * @param verifySize
     * @return
     * @throws IOException
     */
    public static String outputVerifyImage(int w, int h, File outputFile, int verifySize) throws IOException{
        String verifyCode = generateVerifyCode(verifySize);
        outputImage(w, h, outputFile, verifyCode);
        return verifyCode;
    }

    /**
     * 输出随机验证码图片流,并返回验证码值
     * @param w
     * @param h
     * @param os
     * @param verifySize
     * @return
     * @throws IOException
     */
    public static String outputVerifyImage(int w, int h, OutputStream os, int verifySize) throws IOException{
        String verifyCode = generateVerifyCode(verifySize);
        outputImage(w, h, os, verifyCode);
        return verifyCode;
    }

    /**
     * 生成指定验证码图像文件
     * @param w
     * @param h
     * @param outputFile
     * @param code
     * @throws IOException
     */
    public static void outputImage(int w, int h, File outputFile, String code) throws IOException{
        if(outputFile == null){
            return;
        }
        File dir = outputFile.getParentFile();
        if(!dir.exists()){
            dir.mkdirs();
        }
        try{
            outputFile.createNewFile();
            FileOutputStream fos = new FileOutputStream(outputFile);
            outputImage(w, h, fos, code);
            fos.close();
        } catch(IOException e){
            throw e;
        }
    }

    /**
     * 输出指定验证码图片流
     * @param w
     * @param h
     * @param os
     * @param code
     * @throws IOException
     */
    public static void outputImage(int w, int h, OutputStream os, String code) throws IOException{
        int verifySize = code.length();
        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
        Random rand = new Random();
        Graphics2D g2 = image.createGraphics();
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,RenderingHints.VALUE_ANTIALIAS_ON);
        Color[] colors = new Color[5];
        Color[] colorSpaces = new Color[] { Color.WHITE, Color.CYAN,
                Color.GRAY, Color.LIGHT_GRAY, Color.MAGENTA, Color.ORANGE,
                Color.PINK, Color.YELLOW };
        float[] fractions = new float[colors.length];
        for(int i = 0; i < colors.length; i++){
            colors[i] = colorSpaces[rand.nextInt(colorSpaces.length)];
            fractions[i] = rand.nextFloat();
        }
        Arrays.sort(fractions);

        g2.setColor(Color.GRAY);// 设置边框色
        g2.fillRect(0, 0, w, h);

        Color c = getRandColor(200, 250);
        g2.setColor(c);// 设置背景色
        g2.fillRect(0, 2, w, h-4);

        //绘制干扰线
        Random random = new Random();
        g2.setColor(getRandColor(160, 200));// 设置线条的颜色
        for (int i = 0; i < 20; i++) {
            int x = random.nextInt(w - 1);
            int y = random.nextInt(h - 1);
            int xl = random.nextInt(6) + 1;
            int yl = random.nextInt(12) + 1;
            g2.drawLine(x, y, x + xl + 40, y + yl + 20);
        }

        // 添加噪点
        float yawpRate = 0.05f;// 噪声率
        int area = (int) (yawpRate * w * h);
        for (int i = 0; i < area; i++) {
            int x = random.nextInt(w);
            int y = random.nextInt(h);
            int rgb = getRandomIntColor();
            image.setRGB(x, y, rgb);
        }

        shear(g2, w, h, c);// 使图片扭曲

        g2.setColor(getRandColor(100, 160));
        int fontSize = h-4;
        Font font = new Font("Algerian", Font.ITALIC, fontSize);
        g2.setFont(font);
        char[] chars = code.toCharArray();
        for(int i = 0; i < verifySize; i++){
            AffineTransform affine = new AffineTransform();
            affine.setToRotation(Math.PI / 4 * rand.nextDouble() * (rand.nextBoolean() ? 1 : -1), (w / verifySize) * i + fontSize/2, h/2);
            g2.setTransform(affine);
            g2.drawChars(chars, i, 1, ((w-10) / verifySize) * i + 5, h/2 + fontSize/2 - 10);
        }

        g2.dispose();
        ImageIO.write(image, "jpg", os);
    }

    private static Color getRandColor(int fc, int bc) {
        if (fc > 255) {
            fc = 255;
        }
        if (bc > 255) {
            bc = 255;
        }
        int r = fc + random.nextInt(bc - fc);
        int g = fc + random.nextInt(bc - fc);
        int b = fc + random.nextInt(bc - fc);
        return new Color(r, g, b);
    }

    private static int getRandomIntColor() {
        int[] rgb = getRandomRgb();
        int color = 0;
        for (int c : rgb) {
            color = color << 8;
            color = color | c;
        }
        return color;
    }

    private static int[] getRandomRgb() {
        int[] rgb = new int[3];
        for (int i = 0; i < 3; i++) {
            rgb[i] = random.nextInt(255);
        }
        return rgb;
    }

    private static void shear(Graphics g, int w1, int h1, Color color) {
        shearX(g, w1, h1, color);
        shearY(g, w1, h1, color);
    }

    private static void shearX(Graphics g, int w1, int h1, Color color) {

        int period = random.nextInt(2);

        boolean borderGap = true;
        int frames = 1;
        int phase = random.nextInt(2);

        for (int i = 0; i < h1; i++) {
            double d = (double) (period >> 1)
                    * Math.sin((double) i / (double) period
                    + (6.2831853071795862D * (double) phase)
                    / (double) frames);
            g.copyArea(0, i, w1, 1, (int) d, 0);
            if (borderGap) {
                g.setColor(color);
                g.drawLine((int) d, i, 0, i);
                g.drawLine((int) d + w1, i, w1, i);
            }
        }

    }

    private static void shearY(Graphics g, int w1, int h1, Color color) {

        int period = random.nextInt(40) + 10; // 50;

        boolean borderGap = true;
        int frames = 20;
        int phase = 7;
        for (int i = 0; i < w1; i++) {
            double d = (double) (period >> 1)
                    * Math.sin((double) i / (double) period
                    + (6.2831853071795862D * (double) phase)
                    / (double) frames);
            g.copyArea(i, 0, 1, h1, 0, (int) d);
            if (borderGap) {
                g.setColor(color);
                g.drawLine(i, (int) d, i, 0);
                g.drawLine(i, (int) d + h1, i, h1);
            }

        }

    }
    public static void main(String[] args) throws IOException {
        //获取验证码
        String s = generateVerifyCode(4);
        //将验证码放入图片中
        outputImage(260,60,new File("/Users/chenyannan/Desktop/安工资料/aa.jpg"),s);
        System.out.println(s);
    }
}
```



##### 使用

```java
@RequestMapping("/getImage")
public void getImage(HttpServletResponse response) throws IOException {
    //生成验证码
    String code = VerifyCodeUtils.generateVerifyCode(4);
    //验证码存入图片
    ServletOutputStream os = response.getOutputStream();
    response.setContentType("image/png");
    VerifyCodeUtils.outputImage(220,60,os,code);
}
```

前端接收，直接放入 img 的 src 中

```jsp
<form action="${pageContext.request.contextPath}/user/login" method="post">
    用户名：<input type="text" name="username"><br/>
    密码：<input type="text" name="password"><br/>
    请输入验证码：<input type="text" /><img src="${pageContext.request.contextPath}/user/getImage" alt="" /><br />
    <input type="submit" value="登录">
</form>
```



### 1.7 常用

#### 1.7.1 在项目中获取 bean 对象

##### 定义

```java
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class SpringContextUtils implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        SpringContextUtils.applicationContext = applicationContext;
    }

    public static ApplicationContext getApplicationContext() {
        assertApplicationContext();
        return applicationContext;
    }

    public static Object getBean(String name) {
        assertApplicationContext();
        return applicationContext.getBean(name);
    }

    public static <T> T getBean(String name, Class<T> requiredType) {
        assertApplicationContext();
        return applicationContext.getBean(name, requiredType);
    }

    public static boolean containsBean(String name) {
        assertApplicationContext();
        return applicationContext.containsBean(name);
    }

    public static boolean isSingleton(String name) {
        assertApplicationContext();
        return applicationContext.isSingleton(name);
    }

    public static Class<? extends Object> getType(String name) {
        assertApplicationContext();
        return applicationContext.getType(name);
    }

    private static void assertApplicationContext() {
        if (SpringContextUtils.applicationContext == null) {
            throw new RuntimeException("applicaitonContext属性为null,请检查是否注入了SpringContextUtils!");
        }
    }
}
```



##### 使用

```java
UserService userService = (UserService) SpringContextUtils.getBean("userService");
```



#### 1.7.2  JSON字符串和类互转

例如将数据存到 redis 中时，可以用这个类将实体类转换成 json 字符串，存储，也可以从 json 字符串转换成对应的实体类

```jade
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

/**
 * json工具类(jackjson)
 */
public class JSONUtils {

	private final static ObjectMapper objectMapper = new ObjectMapper();

    private JSONUtils() {

    }

    public static ObjectMapper getInstance() {
        return objectMapper;
    }

    /**
     * object转化json
     * @param obj
     * @return
     * @throws Exception
     */
    public static String beanToJson(Object obj) {
        try {
			return objectMapper.writeValueAsString(obj);
		} catch (JsonProcessingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        return null;
    }

    /**
     * json转对象
     * @param jsonStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> T jsonToBean(String jsonStr, Class<T> clazz) {
        try {
			return objectMapper.readValue(jsonStr, clazz);
		} catch (JsonParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (JsonMappingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        return null;
    }

    /**
     * json转map
     * @param jsonStr
     * @return
     * @throws Exception
     */
    @SuppressWarnings("unchecked")
	public static <T> Map<String, Object> jsonToMap(String jsonStr)
            throws Exception {
        return objectMapper.readValue(jsonStr, Map.class);
    }

    /**
     * json转map，指定类型
     * @param jsonStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> Map<String, T> jsonToMap(String jsonStr, Class<T> clazz)
            throws Exception {
        Map<String, Map<String, Object>> map = (Map<String, Map<String, Object>>) objectMapper.readValue(jsonStr,
                new TypeReference<Map<String, T>>() {
                });
        Map<String, T> result = new HashMap<String, T>();
        for (Entry<String, Map<String, Object>> entry : map.entrySet()) {
            result.put(entry.getKey(), mapToBean(entry.getValue(), clazz));
        }
        return result;
    }

    /**
     * json数组转list，指定类型
     * @param jsonArrayStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> List<T> jsonToList(String jsonArrayStr, Class<T> clazz)
            throws Exception {
        List<Map<String, Object>> list = (List<Map<String, Object>>) objectMapper.readValue(jsonArrayStr,
                new TypeReference<List<T>>() {
                });
        List<T> result = new ArrayList<T>();
        for (Map<String, Object> map : list) {
            result.add(mapToBean(map, clazz));        }
        return result;
    }

    /**
     * map转化对象
     */
    @SuppressWarnings("rawtypes")
	public static <T> T mapToBean(Map map, Class<T> clazz) {
        return objectMapper.convertValue(map, clazz);
    }
}
```



#### 1.7.3 序列化工具

##### 定义

```java
/**
 * 序列化工具
 */
public class SerializableUtils {

    /**
     * 将对象序列化成字符串
     * @param object
     * @return
     */
    public static String serialize(Object object) {
        if (null == object) {
            return null;
        }
        try {
            ByteArrayOutputStream bos = new ByteArrayOutputStream();
            ObjectOutputStream oos = new ObjectOutputStream(bos);
            oos.writeObject(object);
            return Base64.encodeToString(bos.toByteArray());
        } catch (Exception e) {
            throw new RuntimeException("serialize error", e);
        }
    }

    /**
     * 将序列化的字符串反转成对象
     * @param serializedStr
     * @return
     */
    public static Object deserialize(String serializedStr) {
        if (StringUtils.isBlank(serializedStr)) {
            return null;
        }
        try {
            ByteArrayInputStream bis = new ByteArrayInputStream(Base64.decode(serializedStr));
            ObjectInputStream ois = new ObjectInputStream(bis);
            return ois.readObject();
        } catch (Exception e) {
            throw new RuntimeException("deserialize error", e);
        }
    }
}
```

序列化的对象需要支持序列化操作

```java
@Data
public class ShiroUserVO implements Serializable {
    private static final long serialVersionUID = 1L;

    private String account;
    private List<Role> roles;
    private List<Perms> perms;
}
```



##### 使用

```java
// 序列化
String shiroStr = SerializableUtils.serialize(newShiroUserVO);

// 反序列化
ShiroUserVO shiroUserVO = (ShiroUserVO) SerializableUtils.deserialize(authorStr);
```







## 二、SpringMvc

### 2.1 使用 Junit4 写测试单元

先引入依赖：

```java
<!-- 单元测试 -->
<dependency>
    <groupId>junit</groupId>
    <artifactId>junit</artifactId>
    <version>${junit.version}</version>
    <scope>test</scope>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-test</artifactId>
    <version>${spring-text.version}</version>
</dependency>
```

编写单元测试类，注意添加上注解

```java
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration(locations = {
        "classpath:spring/applicationContext-dao.xml",
        "classpath:spring/applicationContext-service.xml"
})
public class TestUnit {

    @Autowired
    private TbItemMapper tbItemMapper;

    @Autowired
    private ItemService itemService;

    @Test
    public void mapperTest() {
        TbItem itemById = itemService.getItemById(Long.valueOf(536563));
        System.out.println(itemById.toString());
    }
}
```



### 2.2 引入 PageHelper 分页插件

#### 2.2.1 配置

引入依赖

```java
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>5.1.10</version>
</dependency>
```

SqlMapConfig.xml 中配置

```java
<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <!--配置开启自动匹配驼峰-->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
    <!--配置PageHelper分页插件拦截器-->
    <plugins>
        <plugin interceptor="com.github.pagehelper.PageInterceptor">
            <!--            <property name="offsetAsPageNum" value="true"/>-->
            <property name="helperDialect" value="mysql"/>
            <!--            <property name="rowBoundsWithCount" value="true"/>-->

            <!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 -->
            <!-- 启用合理化时，如果pageNum<1会查询第一页，如果pageNum>pages会查询最后一页 -->
            <!-- 禁用合理化时，如果pageNum<1或pageNum>pages会返回空数据 -->
            <!-- <property name="reasonable" value="false"/> -->
        </plugin>
    </plugins>
</configuration>
```



#### 2.2.2 使用

给 PageHelper.startPage 传入当前页码和需要的行数，之后根据数据库查出的数据获取到 PageInfo

```java
@Override
public Page getItemList(int page, int rows) {
    // 分页处理
    PageHelper.startPage(page, rows);
    List<TbItem> lists = tbItemMapper.getList();
    if(lists != null) {
        Page result = new Page();
        result.setRows(lists);

        // 记录总条数
        PageInfo<TbItem> pageInfo = new PageInfo<>(lists);
        result.setTotal(pageInfo.getTotal());

        return result;
    }
    return null;
}
```



### 2.3 utils 类中使用配置类的方法

##### **现象**

若在 utils 类中需要用到 config.properties 中的方法，在构造类中获取配置类提供的数据时，会发现读取的配置类的对象是 null，继而抛出java.lang.NullPointException



##### **原因**

由于 spring 容器的生成顺序是： 

Constructor(构造方法) -> @Autowired(依赖注入) -> @PostConstruct(注释的方法)

故当工具类的构造方法运行时，配置类的依赖还未注入，获取到的自然是 null 了



##### **解决方案**

###### 方案一：使用静态方法

```java
@Component
public class JedisClusterClient {

    private static JedisConfig jedisConfig;

    private JedisCluster jedisCluster;

    @Autowired
    public JedisClusterClient(JedisConfig jedisConfig) {
        JedisClusterClient.jedisConfig = jedisConfig;

        HashSet<HostAndPort> nodes = new HashSet<>();
        nodes.add(new HostAndPort("www.gtom.top", 7002));
        nodes.add(new HostAndPort("www.gtom.top", 7003));
        nodes.add(new HostAndPort("www.gtom.top", 7004));
        nodes.add(new HostAndPort("www.gtom.top", 7005));
        nodes.add(new HostAndPort("www.gtom.top", 7006));
        nodes.add(new HostAndPort("www.gtom.top", 7001));

        // 配置Redis信息
        JedisPoolConfig config = initPool();
        jedisCluster= new JedisCluster(nodes, jedisConfig.getTimeout(), jedisConfig.getTimeout(), 3, jedisConfig.getPassword(), config);
    }

    public JedisPoolConfig initPool() {
        // 配置Redis信息
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxTotal(10);
        config.setMaxIdle(5);
        config.setMaxWaitMillis(3000);
        config.setTestOnBorrow(true);
        config.setTestOnReturn(true);
        return config;
    }

    public void close() {
        try {
            jedisCluster.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    ......
}

```



###### 方案二：使用 @PostConstruct 注解

调用顺序：

Constructor(构造方法) -> @Autowired(依赖注入) -> @PostConstruct(注释的方法)

通过调用顺序可以发现：@PostContruct 修饰的方法说在依赖注入完成之后被调用的。它修饰了一个 void 返回值的 init 方法，在对象注入完成后会被调用一次

```java
@Component
public class JedisClusterClient {

    @Autowired
    private JedisConfig jedisConfig;

    private JedisCluster jedisCluster;

    @PostConstruct
    public void init() {
        System.out.println("JedisCLustClient  啊 autowired!!!!");

        HashSet<HostAndPort> nodes = new HashSet<>();
        nodes.add(new HostAndPort("www.gtom.top", 7002));
        nodes.add(new HostAndPort("www.gtom.top", 7003));
        nodes.add(new HostAndPort("www.gtom.top", 7004));
        nodes.add(new HostAndPort("www.gtom.top", 7005));
        nodes.add(new HostAndPort("www.gtom.top", 7006));
        nodes.add(new HostAndPort("www.gtom.top", 7001));

        // 配置Redis信息
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxTotal(10);
        config.setMaxIdle(5);
        config.setMaxWaitMillis(3000);
        config.setTestOnBorrow(true);
        config.setTestOnReturn(true);

        jedisCluster= new JedisCluster(nodes, jedisConfig.getTimeout(), jedisConfig.getTimeout(), 3, jedisConfig.getPassword(), config);
    }

    public JedisPoolConfig initPool() {
        // 配置Redis信息
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxTotal(10);
        config.setMaxIdle(5);
        config.setMaxWaitMillis(3000);
        config.setTestOnBorrow(true);
        config.setTestOnReturn(true);
        return config;
    }

    public void close() {
        try {
            jedisCluster.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

	......
}

```



### 2.4 mybatis-generator + tkmybatis

###### 引入依赖

```xml
<dependencies>
    <dependency>
        <groupId>com.upload</groupId>
        <artifactId>upload-plat-user-pojo</artifactId>
        <version>1.0-SNAPSHOT</version>
    </dependency>
    <!-- mybatis -->
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
    </dependency>
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis-spring</artifactId>
    </dependency>
    <dependency>
        <groupId>com.github.miemiedev</groupId>
        <artifactId>mybatis-paginator</artifactId>
    </dependency>
    <dependency>
        <groupId>com.github.pagehelper</groupId>
        <artifactId>pagehelper</artifactId>
    </dependency>
	<!-- 通用Mapper -->
    <dependency>
        <groupId>tk.mybatis</groupId>
        <artifactId>mapper</artifactId>
        <version>3.3.9</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis.generator</groupId>
        <artifactId>mybatis-generator-core</artifactId>
        <version>1.3.7</version>
    </dependency>

    <!-- MySql -->
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    <!-- 连接池 -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>druid</artifactId>
    </dependency>
</dependencies>
```



###### 修改 mapperXX.xml 的存放位置

**在 pom.xml 中配置 mapper 的 xml 存放位置**

```xml
<build>
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>true</filtering>
        </resource>
    </resources>
</build>
```



###### 修改 applicationContext-dao.xml

记得将 MapperScannerConfigurer 交给 tkmybatis，并修改对应路径

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p"
       xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
	http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
	http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.0.xsd
	http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util-4.0.xsd">

    <!-- 数据库连接池 -->
    <!-- 加载配置文件 -->
    <context:property-placeholder location="classpath:db.properties" ignore-unresolvable="true"/>

    <!-- 数据库连接池 -->
    <bean id="dataSource" class="${jdbc.type}"
          destroy-method="close">
        <property name="url" value="${jdbc.url}" />
        <property name="username" value="${jdbc.username}" />
        <property name="password" value="${jdbc.password}" />
        <property name="driverClassName" value="${jdbc.driver}" />
        <!-- 最大连接池数量 -->
        <property name="maxActive" value="${jdbc.maxActive}" />
        <!-- 最小连接池数量 -->
        <property name="minIdle" value="${jdbc.minIdle}" />
        <!-- 初始连接数 -->
        <property name="initialSize" value="${jdbc.initialSize}"/>
        <!-- 获取连接等待超时时间 -->
        <property name="maxWait" value="${jdbc.maxWait}"/>
        <!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->
        <property name="timeBetweenEvictionRunsMillis" value="${jdbc.timeBetweenEvictionRunsMillis}"/>
        <!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->
        <property name="minEvictableIdleTimeMillis" value="${jdbc.minEvictableIdleTimeMillis}"/>
        <!-- 配置检测连接是否有效 -->
        <property name="validationQuery" value="${jdbc.validationquery}"/>
        <property name="testWhileIdle" value="${jdbc.testWhileIdle}"/>
        <property name="testOnBorrow" value="${jdbc.testOnBorrow}"/>
        <property name="testOnReturn" value="${jdbc.testOnReturn}"/>
    </bean>


    <!-- 让spring管理sqlsessionfactory 使用mybatis和spring整合包中的 -->
    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <!-- 数据库连接池 -->
        <property name="dataSource" ref="dataSource" />
        <!-- 加载mybatis的全局配置文件 -->
        <property name="configLocation" value="classpath:mybatis/mybatis.xml" />
    </bean>

<!--    &lt;!&ndash;  配置扫描包，加载mapper代理对象  &ndash;&gt;-->
<!--    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">-->
<!--        <property name="basePackage" value="com.upload.user.mapper" />-->
<!--    </bean>-->

    <!-- mybatis 通用 mapper 整合-->
    <bean class="tk.mybatis.spring.mapper.MapperScannerConfigurer">
        <!-- mapper 扫描交给 tkmybatis 扫描 -->
        <property name="basePackage" value="com.upload.file.mapper"/>
        <property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />
        <property name="markerInterface" value="com.upload.file.tk.BaseMapper"/>
        <!-- 通用Mapper通过属性注入进行配置，默认不配置时会注册Mapper<T>接口 -->
        <property name="properties">
            <value>
                <!--配置参数-->
                ORDER=BEFORE
            </value>
        </property>
    </bean>

</beans>
```

###### 新建 mybatis.xml

mybatis.xml 文件路径定义在了 applicationContext-dao.xml 中

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration
        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">

<!-- mybatis的主配置文件 -->
<configuration>
    <!--配置开启自动匹配驼峰-->
    <settings>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
    </settings>
<!--    &lt;!&ndash;  使用typeAliases配置别名，但只能配置domain中类的别名，使用指定的别名不区分大小写  &ndash;&gt;-->
<!--    <typeAliases>-->
<!--        &lt;!&ndash;        <typeAlias type="xyz.tom.www.domain.User" alias="user"></typeAlias>&ndash;&gt;-->
<!--        &lt;!&ndash; 用于指定要配置别名的包，当指定后，该包下的实体类都会注册别名，且类名就是别名，不区分大小写 &ndash;&gt;-->
<!--        <package name="com.upload.user.mapper"/>-->
<!--    </typeAliases>-->

<!--    &lt;!&ndash;  指定映射配置文件的位置，映射配置文件指的是每个dao独立的配置文件  &ndash;&gt;-->
<!--    <mappers>-->
<!--        &lt;!&ndash;    package是用于指定dao接口所在的包，当指定之后，就不需要再写mapper以及resource或者class了    &ndash;&gt;-->
<!--        <package name="com/upload/user/mapper"/>-->
<!--    </mappers>-->
</configuration>
```



###### 增加数据库配置文件 db.properties

```
jdbc.driver=com.mysql.cj.jdbc.Driver
jdbc.type=com.alibaba.druid.pool.DruidDataSource
jdbc.url=jdbc:mysql://www.gtom.top:3306/upload_plat?useUnicode=true&characterEncoding=utf-8&useSSL=false&nullCatalogMeansCurrent=true
jdbc.username=root
jdbc.password=root

# 初始连接数
jdbc.initialSize=5
# 最小连接池数量
jdbc.minIdle=10
# 最大连接池数量
jdbc.maxActive=20
# 配置获取连接等待超时的时间
jdbc.maxWait=60000
# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
jdbc.timeBetweenEvictionRunsMillis=60000
# 配置一个连接在池中最小生存的时间，单位是毫秒
jdbc.minEvictableIdleTimeMillis=300000
# 配置检测连接是否有效
jdbc.validationquery=SELECT 1
jdbc.testWhileIdle=true
jdbc.testOnBorrow=false
jdbc.testOnReturn=false

# 网络统计和监控
jdbc.webStatFilter.enable=false
jdbc.statViewServlet.enabled=false
# 设置白名单，不填则允许所有访问
jdbc.allow.url-pattern=/druid/*
# 控制台管理用户名和密码
jdbc.login-username:
jdbc.login-password:
jdbc.filter.stat.enabled=true

# 慢SQL记录
jdbc.log-slow-sql=true
jdbc.slow-sql-millis=1000
jdbc.merge-sql=true
jdbc.wall.config.multi-statement-allow=true

# 用于 mybatis-generator 逆向生成代码
MYBATIS_GENERATOR_POJO_PATH=E:\\xxx\\upload-plat-file\\src\\main\\java
MYBATIS_GENERATOR_DAO_PATH=E:\\xxx\\upload-plat-file\\src\\main\\java
MYBATIS_GENERATOR_PACKAGE_PATH=com.upload.file
```



###### 编写逆向工程的配置文件

由于结合了 swagger 和 tkmybatis，两者在同一个配置文件内时 tkmybatis 会导致写 swagger 注解的扩展类失效，故分为两份配置文件，先调用 tkmybatis的生成 mapper 相关文件，而后调用 swagger 的生成 pojo 文件。

 generatorConfig-tk.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <!-- 引入配置文件 -->
    <properties resource="db.properties"/>

    <!-- 一个数据库一个context -->
    <context id="DB2Tables" targetRuntime="MyBatis3">
        <!-- 生成的 Java 文件的编码 -->
        <property name="javaFileEncoding" value="UTF-8"/>
        <!-- 格式化 Java 代码 -->
        <property name="javaFormatter" value="org.mybatis.generator.api.dom.DefaultJavaFormatter"/>
        <!-- 格式化 XML 代码 -->
        <property name="xmlFormatter" value="org.mybatis.generator.api.dom.DefaultXmlFormatter"/>

        <!-- 配置 tk.mybatis 插件，tkmybatis的基类不能与其他mapper放在一起 -->
        <plugin type="tk.mybatis.mapper.generator.MapperPlugin">
            <property name="mappers" value="com.upload.file.tk.BaseMapper"/>
        </plugin>
        <plugin type="org.mybatis.generator.plugins.SerializablePlugin"/>
        <!-- 为生成的Java模型创建一个toString方法 -->
        <plugin type="org.mybatis.generator.plugins.ToStringPlugin"/>

        <!-- 自定义注释生成器 -->
        <commentGenerator type="com.mybatis.generator.MyCommentGenerator">
            <property name="author" value="tom"/>
        </commentGenerator>

        <jdbcConnection driverClass="${jdbc.driver}"
                        connectionURL="${jdbc.url}" userId="${jdbc.username}"
                        password="${jdbc.password}"/>

        <javaModelGenerator targetPackage="${MYBATIS_GENERATOR_PACKAGE_PATH}.entity"
                            targetProject="${MYBATIS_GENERATOR_POJO_PATH}">
            <!-- 是否允许子包，即targetPackage.schemaName.tableName -->
            <property name="enableSubPackages" value="false"/>
            <!-- 是否对model添加 构造函数 -->
            <property name="constructorBased" value="false"/>
            <!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 -->
            <property name="immutable" value="false"/>
            <!-- 设置是否在getter方法中，对String类型字段调用trim()方法 -->
            <property name="trimStrings" value="false"/>
        </javaModelGenerator>

        <sqlMapGenerator targetPackage="${MYBATIS_GENERATOR_PACKAGE_PATH}.mapper"
                         targetProject="${MYBATIS_GENERATOR_DAO_PATH}">
            <property name="enableSubPackages" value="false"/>
        </sqlMapGenerator>

        <javaClientGenerator targetPackage="${MYBATIS_GENERATOR_PACKAGE_PATH}.mapper"
                             targetProject="${MYBATIS_GENERATOR_DAO_PATH}" type="XMLMAPPER">
            <property name="enableSubPackages" value="false"/>
        </javaClientGenerator>

        <table tableName="upload_record" domainObjectName="Record"
               enableCountByExample="false" enableUpdateByExample="false"
               enableDeleteByExample="false" enableSelectByExample="false"
               selectByExampleQueryId="false">
            <!--<columnRenamingRule searchString="^D_"
                                replaceString=""/>-->
        </table>
    </context>
</generatorConfiguration>
```

 generatorConfig-pojo.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
    <!-- 引入配置文件 -->
    <properties resource="db.properties"/>

    <!-- 一个数据库一个context -->
    <context id="DB2Tables" targetRuntime="MyBatis3">
        <!-- 生成的 Java 文件的编码 -->
        <property name="javaFileEncoding" value="UTF-8"/>
        <!-- 格式化 Java 代码 -->
        <property name="javaFormatter" value="org.mybatis.generator.api.dom.DefaultJavaFormatter"/>
        <!-- 格式化 XML 代码 -->
        <property name="xmlFormatter" value="org.mybatis.generator.api.dom.DefaultXmlFormatter"/>

        <!-- 为生成的Java模型创建一个toString方法 -->
        <plugin type="org.mybatis.generator.plugins.ToStringPlugin"/>

        <!-- 自定义注释生成器 -->
        <commentGenerator type="com.mybatis.generator.MyCommentGenerator">
            <property name="author" value="tom"/>
        </commentGenerator>

        <jdbcConnection driverClass="${jdbc.driver}"
                        connectionURL="${jdbc.url}" userId="${jdbc.username}"
                        password="${jdbc.password}"/>

        <javaModelGenerator targetPackage="${MYBATIS_GENERATOR_PACKAGE_PATH}.entity"
                            targetProject="${MYBATIS_GENERATOR_POJO_PATH}">
            <!-- 是否允许子包，即targetPackage.schemaName.tableName -->
            <property name="enableSubPackages" value="false"/>
            <!-- 是否对model添加 构造函数 -->
            <property name="constructorBased" value="false"/>
            <!-- 建立的Model对象是否 不可改变  即生成的Model对象不会有 setter方法，只有构造方法 -->
            <property name="immutable" value="false"/>
            <!-- 设置是否在getter方法中，对String类型字段调用trim()方法 -->
            <property name="trimStrings" value="false"/>
        </javaModelGenerator>

        <table tableName="upload_record" domainObjectName="Record"
               enableCountByExample="false" enableUpdateByExample="false"
               enableDeleteByExample="false" enableSelectByExample="false"
               selectByExampleQueryId="false">
            <!--<columnRenamingRule searchString="^D_"
                                replaceString=""/>-->
        </table>
    </context>
</generatorConfiguration>
```



###### 增加自定义扩展类

由于兼容了 swaggerui， 要自定义给他加上注解，故需要定义扩展类 MyCommentGenerator.java

```java
public class MyCommentGenerator implements CommentGenerator{

    /**
     * properties配置文件
     */
    private Properties properties;
    /**
     * properties配置文件
     */
    private Properties systemPro;

    /*
     * 父类时间
     */
    private boolean suppressDate;

    /**
     * 父类所有注释
     */
    private boolean suppressAllComments;

    /**
     * 当前时间
     */
    private String currentDateStr;

    public MyCommentGenerator() {
        super();
        properties = new Properties();
        systemPro = System.getProperties();
        suppressDate = false;
        suppressAllComments = false;
        currentDateStr = (new SimpleDateFormat("yyyy-MM-dd")).format(new Date());
    }

    /**
     * Java类的类注释
     */
    @Override
    public void addClassComment(InnerClass innerClass, IntrospectedTable introspectedTable) {
        if (suppressAllComments) {
            return;
        }

        StringBuilder sb = new StringBuilder();
        innerClass.addJavaDocLine("/**");
        sb.append(" * ");
        sb.append(introspectedTable.getFullyQualifiedTable());
        sb.append(" ");
        sb.append(getDateString());
        innerClass.addJavaDocLine(sb.toString().replace("\n", " "));
        innerClass.addJavaDocLine(" */");
    }

    /**
     * 为类添加注释
     */
    @Override
    public void addClassComment(InnerClass innerClass, IntrospectedTable introspectedTable, boolean markAsDoNotDelete) {
        if (suppressAllComments) {
            return;
        }
        StringBuilder sb = new StringBuilder();
        innerClass.addJavaDocLine("/**");
        sb.append(" * ");
        sb.append(" * ");
        sb.append(introspectedTable.getFullyQualifiedTable());
        innerClass.addJavaDocLine(sb.toString().replace("\n", " "));
        sb.setLength(0);
        sb.append(" * @author ");
        sb.append(systemPro.getProperty("user.name"));
        sb.append(" ");
        sb.append(currentDateStr);
        innerClass.addJavaDocLine(" */");
    }


    /**
     * Mybatis的Mapper.xml文件里面的注释
     */
    @Override
    public void addComment(XmlElement xmlElement) {

    }

    /**
     *
     *@Title addConfigurationProperties
     *@Description: 从该配置中的任何属性添加此实例的属性CommentGenerator配置。
     *              这个方法将在任何其他方法之前被调用。
     *@Author fendo
     *@Date 2017年10月5日 下午3:45:58
     *@return
     *@throws
     */
    @Override
    public void addConfigurationProperties(Properties properties) {
        this.properties.putAll(properties);
        suppressDate = isTrue(properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_SUPPRESS_DATE));
        suppressAllComments = isTrue(properties.getProperty(PropertyRegistry.COMMENT_GENERATOR_SUPPRESS_ALL_COMMENTS));
    }

    /**
     *
     *@Title getDateString
     *@Description: 此方法返回格式化的日期字符串以包含在Javadoc标记中和XML注释。 如果您不想要日期，则可以返回null在这些文档元素中。
     *@Author fendo
     *@Date 2017年10月5日 下午3:45:58
     *@return
     *@throws
     */
    protected String getDateString() {
        String result = null;
        if (!suppressDate) {
            result = currentDateStr;
        }
        return result;
    }

    /**
     *
     *@Title addJavadocTag
     *@Description: 此方法为其添加了自定义javadoc标签。
     *@Author fendo
     *@Date 2017年10月5日 下午3:49:05
     *@param javaElement
     *@param markAsDoNotDelete
     *@throws
     */
    protected void addJavadocTag(JavaElement javaElement, boolean markAsDoNotDelete) {
        javaElement.addJavaDocLine(" *");
        StringBuilder sb = new StringBuilder();
        sb.append(" * ");
        sb.append(MergeConstants.NEW_ELEMENT_TAG);
        if (markAsDoNotDelete) {
            sb.append(" do_not_delete_during_merge");
        }
        String s = getDateString();
        if (s != null) {
            sb.append(' ');
            sb.append(s);
        }
        javaElement.addJavaDocLine(sb.toString());
    }


    /**
     * 为枚举添加注释
     */
    @Override
    public void addEnumComment(InnerEnum innerEnum, IntrospectedTable introspectedTable) {
        if (suppressAllComments) {
            return;
        }
        StringBuilder sb = new StringBuilder();
        innerEnum.addJavaDocLine("/**");
        sb.append(" * ");
        sb.append(introspectedTable.getFullyQualifiedTable());
        innerEnum.addJavaDocLine(sb.toString().replace("\n", " "));
        innerEnum.addJavaDocLine(" */");
    }

    /**
     * Java属性注释
     */
    @Override
    public void addFieldComment(Field field, IntrospectedTable introspectedTable) {
        if (suppressAllComments) {
            return;
        }
        StringBuilder sb = new StringBuilder();
        field.addJavaDocLine("/**");
        sb.append(" * ");
        sb.append(introspectedTable.getFullyQualifiedTable());
        field.addJavaDocLine(sb.toString().replace("\n", " "));
        field.addJavaDocLine(" */");
    }

    /**
     * 为字段添加注释
     */
    @Override
    public void addFieldComment(Field field, IntrospectedTable introspectedTable,IntrospectedColumn introspectedColumn) {
        if (suppressAllComments) {
            return;
        }

        String actualColumnName = introspectedColumn.getActualColumnName();
        if (actualColumnName.equals("id")) {
            field.addJavaDocLine("@Id");
        } else {
            StringBuilder sb = new StringBuilder();
            field.addJavaDocLine("/**");
            sb.append(" * ");
            sb.append(introspectedColumn.getRemarks());
            field.addJavaDocLine(sb.toString().replace("\n", " "));
            field.addJavaDocLine(" */");

            //根据参数和备注信息判断是否添加备注信息
            String remarks = introspectedColumn.getRemarks();
            if(StringUtility.stringHasValue(remarks)){
    //            addFieldJavaDoc(field, remarks);
                //数据库中特殊字符需要转义
                if(remarks.contains("\"")){
                    remarks = remarks.replace("\"","'");
                }
                //给model的字段添加swagger注解
                field.addJavaDocLine("@ApiModelProperty(value = \""+remarks+"\")");
            }
        }
    }

    /**
     * 普通方法的注释，这里主要是XXXMapper.java里面的接口方法的注释
     */
    @Override
    public void addGeneralMethodComment(Method method, IntrospectedTable introspectedTable) {
        if (suppressAllComments) {
            return;
        }
        method.addJavaDocLine("/**");
        addJavadocTag(method, false);
        method.addJavaDocLine(" */");
    }


    /**
     * 给getter方法加注释
     */
    @Override
    public void addGetterComment(Method method, IntrospectedTable introspectedTable,IntrospectedColumn introspectedColumn) {
        if (suppressAllComments) {
            return;
        }
        method.addJavaDocLine("/**");
        StringBuilder sb = new StringBuilder();
        sb.append(" * ");
        sb.append(introspectedColumn.getRemarks());
        method.addJavaDocLine(sb.toString().replace("\n", " "));
        sb.setLength(0);
        sb.append(" * @return ");
        sb.append(introspectedColumn.getActualColumnName());
        sb.append(" ");
        sb.append(introspectedColumn.getRemarks());
        method.addJavaDocLine(sb.toString().replace("\n", " "));
        method.addJavaDocLine(" */");
    }

    /**
     * 给Java文件加注释，这个注释是在文件的顶部，也就是package上面。
     */
    @Override
    public void addJavaFileComment(CompilationUnit compilationUnit) {
        SimpleDateFormat sdf=new SimpleDateFormat("yyyy-MM-dd");
        compilationUnit.addFileCommentLine("/*");
        compilationUnit.addFileCommentLine("*");
        compilationUnit.addFileCommentLine("* "+compilationUnit.getType().getShortName()+".java");
        compilationUnit.addFileCommentLine("* Copyright(C) 2017-2021 tom");
        compilationUnit.addFileCommentLine("* @date "+sdf.format(new Date())+"");
        compilationUnit.addFileCommentLine("*/");
    }

    /**
     * 为模型类添加注释
     */
    @Override
    public void addModelClassComment(TopLevelClass topLevelClass, IntrospectedTable introspectedTable) {
        // 获取表注释
        TableConfiguration tableConfiguration = introspectedTable.getTableConfiguration();
        String tableName = tableConfiguration.getTableName();
        topLevelClass.addJavaDocLine("@Table(name = \"" + tableName +"\")");

        String remarks = introspectedTable.getRemarks();
        if (!StringUtils.isEmpty(remarks)) {
            topLevelClass.addJavaDocLine("@ApiModel(description = \""+ remarks + "\")");
        }
    }

    /**
     * 为调用此方法作为根元素的第一个子节点添加注释。
     */
    @Override
    public void addRootComment(XmlElement arg0) {

    }

    @Override
    public void addGeneralMethodAnnotation(Method method, IntrospectedTable introspectedTable, Set<FullyQualifiedJavaType> imports) {

    }

    @Override
    public void addGeneralMethodAnnotation(Method method, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn, Set<FullyQualifiedJavaType> imports) {

    }

    @Override
    public void addFieldAnnotation(Field field, IntrospectedTable introspectedTable, Set<FullyQualifiedJavaType> imports) {

    }

    @Override
    public void addFieldAnnotation(Field field, IntrospectedTable introspectedTable, IntrospectedColumn introspectedColumn, Set<FullyQualifiedJavaType> imports) {

    }

    @Override
    public void addClassAnnotation(InnerClass innerClass, IntrospectedTable introspectedTable, Set<FullyQualifiedJavaType> imports) {

    }

    /**
     * 给setter方法加注释
     */
    @Override
    public void addSetterComment(Method method, IntrospectedTable introspectedTable,IntrospectedColumn introspectedColumn) {
        if (suppressAllComments) {
            return;
        }
        method.addJavaDocLine("/**");
        StringBuilder sb = new StringBuilder();
        sb.append(" * ");
        sb.append(introspectedColumn.getRemarks());
        method.addJavaDocLine(sb.toString().replace("\n", " "));
        Parameter parm = method.getParameters().get(0);
        sb.setLength(0);
        sb.append(" * @param ");
        sb.append(parm.getName());
        sb.append(" ");
        sb.append(introspectedColumn.getRemarks());
        method.addJavaDocLine(sb.toString().replace("\n", " "));
        method.addJavaDocLine(" */");
    }

}
```



###### 编写启动类

好了，以后一步就是编写启动类，让他来创建文件了

Generator.java

```
public class Generator {
    public static void main(String[] args) throws Exception {
        doCreate("/utils/generatorConfig-tk.xml");
        doCreate("/utils/generatorConfig-pojo.xml");
    }

    public static void doCreate(String configUrl) throws Exception {
        //MBG 执行过程中的警告信息
        List<String> warnings = new ArrayList<String>();
        //当生成的代码重复时，覆盖原代码
        boolean overwrite = true;
        //读取我们的 MBG 配置文件
        InputStream is = Generator.class.getResourceAsStream(configUrl);
        ConfigurationParser cp = new ConfigurationParser(warnings);
        Configuration config = cp.parseConfiguration(is);
        is.close();

        DefaultShellCallback callback = new DefaultShellCallback(overwrite);
        //创建 MBG
        MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
        //执行生成代码
        myBatisGenerator.generate(null);
        //输出警告信息
        for (String warning : warnings) {
            System.out.println(warning);
        }
    }
}
```







#### 2.4.2  使用 mybatis-generator 

结合了 tkmybatis，无需写更多的xml即可使用



**增加 mybatis-generator 的配置文件 generatorConfig.xml**

这个配置文件的位置在 pom.xml 中有指定

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">

<generatorConfiguration>
    <!-- 引入配置文件 -->
    <properties resource="db.properties"/>

    <!-- 一个数据库一个context -->
    <context id="DB2Tables" targetRuntime="MyBatis3">
        <!-- 配置 tk.mybatis 插件，tkmybatis的基类不能与其他mapper放在一起 -->
        <plugin type="tk.mybatis.mapper.generator.MapperPlugin">
            <property name="mappers" value="com.upload.user.tk.BaseMapper"/>
        </plugin>

        <commentGenerator>
            <!-- 是否生成注释代时间戳-->
            <property name="suppressDate" value="false"/>
            <!-- 是否取消注释 -->
            <property name="suppressAllComments" value="true"/>
        </commentGenerator>

        <jdbcConnection driverClass="${jdbc.driver}"
                        connectionURL="${jdbc.url}" userId="${jdbc.username}"
                        password="${jdbc.password}"/>

        <javaModelGenerator targetPackage="${MYBATIS_GENERATOR_PACKAGE_PATH}.entity"
                            targetProject="${MYBATIS_GENERATOR_PATH}">
            <property name="enableSubPackages" value="true"/>
            <property name="trimStrings" value="true"/>
        </javaModelGenerator>

        <sqlMapGenerator targetPackage="${MYBATIS_GENERATOR_PACKAGE_PATH}.mapper"
                            targetProject="${MYBATIS_GENERATOR_PATH}">
            <property name="enableSubPackages" value="false"/>
        </sqlMapGenerator>

        <javaClientGenerator targetPackage="${MYBATIS_GENERATOR_PACKAGE_PATH}.mapper"
                             targetProject="${MYBATIS_GENERATOR_PATH}" type="XMLMAPPER">
            <property name="enableSubPackages" value="false"/>
        </javaClientGenerator>

        <table tableName="user" domainObjectName="User"
               enableCountByExample="false" enableUpdateByExample="false"
               enableDeleteByExample="false" enableSelectByExample="false"
               selectByExampleQueryId="false">
            <!--<columnRenamingRule searchString="^D_"
                                replaceString=""/>-->
        </table>
        <table tableName="upload_record" domainObjectName="Record"
               enableCountByExample="false" enableUpdateByExample="false"
               enableDeleteByExample="false" enableSelectByExample="false"
               selectByExampleQueryId="false">
            <!--<columnRenamingRule searchString="^D_"
                                replaceString=""/>-->
        </table>
    </context>
</generatorConfiguration>
```

**可以把 mapper 里面的代码删除掉，保持干净**

**注意：**如果不用了则把插件删除掉，否则会被覆盖，mapper 代码会重复添加到文件中



#### **2.4.3 api 解释**

http://www.youbiji.cn/doc/mybatis/xml-javaModelGenerator.html



### 2.5 通用异常处理

在项目中后端抛出异常，可能导致前端返回的数据格式乱掉，故需要定义一个通用异常类来处理，返回特定格式的数据

**注意：异常类需要能够被扫描到！！！！！否则无效**

定义异常捕捉类

```java
/**
 * 统一异常处理
 */
@ControllerAdvice
@Component
public class GlobalExceptionHandler {

	// 自定义异常处理
    @ExceptionHandler(CommonException.class)
    @ResponseBody
    public R handleMyException(CommonException e){
        return R.error(e.getCode(), e.getMessage());
    }

	// 捕捉所有异常，并返回指定数据格式
    @ExceptionHandler(Exception.class)
    @ResponseBody
    public R handleMyException(Exception e){
        return R.error(CodeConstant.ERROR, e.getMessage());
    }
}
```

自定义异常定义

```java
public class CommonException extends Exception {

    private int code;
    private String message;

    public CommonException(String message) {
        this.code = CodeConstant.ERROR;
        this.message = message;
    }

    public CommonException(int code, String message) {
        this.code = code;
        this.message = message;
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    @Override
    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }
}
```



## 三、Tomcat

### 3.1 CentOS 服务器部署 Tomcat

#### 3.1.1 部署和启动

**下载安装包，安装**

```
# 下载
wget https://mirrors.tuna.tsinghua.edu.cn/apache/tomcat/tomcat-8/v8.5.60/bin/apache-tomcat-8.5.60.tar.gz

# 解压和重命名
tar -zxvf apache-tomcat-8.5.60.tar.gz 
mv apache-tomcat-8.5.60 tomcat8
```

**启动/关闭 tomcat**

```
# 启动
sh /opt/tomcat8/bin/startup.sh

# 关闭
sh /opt/tomcat8/bin/shutdown.sh
```

**使用自己的网站**

将 war 包上传到 webapps 下，并在访问路径后加上自己的 war 包名称

```
如 war 包名为： tmanager.war
访问： http://www.xxx.com:8080/tmanager/
```



#### 3.1.2 配置

##### 3.1.2.1 配置 idea生成的 war  包名称

```
# 在 pom.xml 的 builder 中配置
<finalName>tmanager</finalName>
```



### 3.2 Tomcat 配置

#### 3.2.1 server.xml 配置列表

| 元素名                                     | 属性              | 解释                                                         |
| :----------------------------------------- | ----------------- | ------------------------------------------------------------ |
| **server**                                 | port              | 指定一个端口，负责监听和关闭 tomcat 请求                     |
|                                            | shutdown          | 指定向端口发送的命令字符串                                   |
| **service**                                | name              | 指定 service 的名字                                          |
| **Connector**                              | port              | 指定项目要使用的端口号，通过这个端口来监听客户端的请求       |
|                                            | minProcessors     | 服务器启动时创建的处理请求的线程数                           |
|                                            | maxProcessors     | 最大可创建的处理请求的线程数                                 |
|                                            | enableLookups     | 是否允许DNS查询                                              |
|                                            | redirectPort      | 服务器处理http请求时收到SSL传输请求后重定向的端口号          |
|                                            | acceptCount       | 指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理 |
|                                            | connectionTimeout | 指定超时的时间数(以毫秒为单位)                               |
| **Engine (处理请求)**                      | defaultHost       | 指定缺省的处理请求的主机名，它至少与其中的一个host元素的name属性值是一样的 |
| **Context (表示一个应用程序，一般为war**   | docBase           | 应用程序的路径或是war文件存放的路径，可以在 tomcat 之外      |
|                                            | path              | 表示此 web 应用的 url 前缀，即： http://localhost:8080/path/xxxx |
|                                            | reloadable        | 是否自动检测 /WEB-INF/lib 和 /WEB-INF/classes 目录的变化，自动装载新的应用程序。能够保证不重启 tomcat 的情况下改变应用程序 |
| **host (一个虚拟主机)**                    | name              | 指定主机名， Engine 中必须加载 host 中的一个主机名           |
|                                            | appBase           | 存放应用程序的目录，aaa/webapps/aaa.war                      |
|                                            | unpackWARs        | 是否自动解压 war 包。 若是 false，则会直接从 war 文件中运行程序 |
| **Logger(日志存放的位置，名称)**           | className         | 日志使用的类名。必须实现 org.apache.catalina.Logger 接口     |
|                                            | prefix            | 指定log文件的前缀                                            |
|                                            | suffix            | 指定log文件的后缀                                            |
|                                            | timestamp         | 若true，则在 log 文件名中要加入时间                          |
| **Realm (存放用户名、密码及role的数据库)** | className         | 指定Realm使用的类名，此类必须实现org.apache.catalina.Realm接口 |
| **Value (另一种日志)**                     | className         | 指定Valve使用的类名，如用org.apache.catalina.valves.AccessLogValve类可以记录应用程序的访问信息 |
|                                            | directory         | 指定log文件存放的位置                                        |
|                                            | pattern           | 有两个值，common方式记录远程主机名或ip地址，用户名，日期，第一行请求的字符串，HTTP响应代码，发送的字节数。combined方式比common方式记录的值更多 |



#### 3.2.2 配置默认启动项目

默认启动项目即直接使用 ip:端口/ 访问，否则无论说访问页面还是接口请求，都要带上 war 包名称

在 config/server.xml 中， 找到 Host ，配置 Context

```xml
<Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">

        <!-- SingleSignOn valve, share authentication between web applications
             Documentation at: /docs/config/valve.html -->
        <!--
        <Valve className="org.apache.catalina.authenticator.SingleSignOn" />
        -->
	<Context path="" docBase="tmanager" debug="0" reloadable="true" />

        <!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern="common" -->
        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix="localhost_access_log" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />

</Host>
```

```
# 配置讲解
Host
  appBase: 指定tomcat访问的项目文件夹，文件夹下可以存放多个项目

Context
  path: 请求路径 即 【ip:端口】/【path】
  docBase: 实际对应的项目路径
```



#### 3.2.3  tomcat 多项目多端口配置

先确定是否在 web.xml 中写入了  webAppsRootKey，每个 web 项目都要有自己唯一的名称

```xml
<context-param>
    <param-name>webAppRootKey</param-name>
    <param-value>tportal</param-value>
</context-param>
```

进入服务器 tomcat 的 config 目录，修改目录下的 service.xml，新增一个 service (一个 service 对应一个工程)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<Server port="8005" shutdown="SHUTDOWN">
  <Listener className="org.apache.catalina.startup.VersionLoggerListener" />
  <Listener className="org.apache.catalina.core.AprLifecycleListener" SSLEngine="on" />
  <Listener className="org.apache.catalina.core.JreMemoryLeakPreventionListener" />
  <Listener className="org.apache.catalina.mbeans.GlobalResourcesLifecycleListener" />
  <Listener className="org.apache.catalina.core.ThreadLocalLeakPreventionListener" />

  <GlobalNamingResources>
    <Resource name="UserDatabase" auth="Container"
              type="org.apache.catalina.UserDatabase"
              description="User database that can be updated and saved"
              factory="org.apache.catalina.users.MemoryUserDatabaseFactory"
              pathname="conf/tomcat-users.xml" />
  </GlobalNamingResources>

<!-- 第一个web应用 -->
  <Service name="Catalina">
    <Connector port="8080" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" />
   <Engine name="Catalina" defaultHost="localhost">
      <Realm className="org.apache.catalina.realm.LockOutRealm">
        <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
               resourceName="UserDatabase"/>
      </Realm>

      <Host name="localhost"  appBase="webapps"
            unpackWARs="true" autoDeploy="true">
         <Context path="" docBase="tmanager" reloadable="true" />
      </Host>
    </Engine>
  </Service>

<!-- 第二个web应用 -->
<Service name="Catalina1">
    <Connector port="8081" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" />
    <Engine name="Catalina1" defaultHost="localhost1">
      <Realm className="org.apache.catalina.realm.LockOutRealm">
        <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
               resourceName="UserDatabase"/>
      </Realm>
           
      <Host name="localhost1"  appBase="webapps1"
            unpackWARs="true" autoDeploy="true">
         <Context path="" docBase="tportal" reloadable="true" />
        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs/tportal"
               prefix="localhost_access_log" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
      </Host> 
    </Engine> 
  </Service>


<!-- 第三个web应用 -->
 <Service name="Catalina2">
    <Connector port="8082" protocol="HTTP/1.1"
               connectionTimeout="20000"
               redirectPort="8443" />
    <Engine name="Catalina2" defaultHost="localhost2">
      <Realm className="org.apache.catalina.realm.LockOutRealm">
        <Realm className="org.apache.catalina.realm.UserDatabaseRealm"
               resourceName="UserDatabase"/>
      </Realm>

      <Host name="localhost2"  appBase="webapps2"
            unpackWARs="true" autoDeploy="true">
         <Context path="" docBase="trest" reloadable="true" />
        <Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs/trest"
               prefix="localhost_access_log" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
      </Host>
    </Engine>
  </Service>
</Server>
```



#### 3.2.4 tomcat 控制台乱码

https://blog.csdn.net/u012611878/article/details/80723491



## 四、数据库

### 4.1 数据库连接不上

原因： 1. 注意pom文件中引入的依赖是否与实际数据库版本一致

​             2. 可以写 count 进行测试



### 4.2 将 Mybatis 的 xml 文件放在 java 文件夹下

在 pom 文件的 build 标签内添加

```xml
<resources>
    <resource>
        <directory>src/main/java</directory>
        <includes>
            <include>**/*.xml</include>
        </includes>
    </resource>
</resources>
```





## 五、Redis

### 5.1 CentOS 部署 Redis

#### 5.1.1 安装和运行

安装 gcc 依赖

```
yum install -y gcc 
gcc -v

#若redis版本6.0.x，则gcc要升级到 5.3及以上版本
yum -y install centos-release-scl
yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils
scl enable devtoolset-9 bash
```

下载安装包，解压重命名

```
wget http://download.redis.io/releases/redis-5.0.3.tar.gz
tar -zxvf redis-5.0.3.tar.gz
mv redis-5.0.3.tar.gz redis
```

执行编译和安装

```
cd /opt/redis
make
make install PREFIX=/opt/redis
```



#### 5.1.2 启动脚本和关闭脚本

启动脚本

````
vim /opt/redis/start.sh

# 脚本内容
./bin/redis-server ./redis.conf
````

关闭脚本

```
vim /opt/redis/stop.sh

# 脚本内容
./bin/redis-cli shutdown
```

修改脚本执行权限

```
chmod +711 start.sh stop.sh
```

运行

```
sh start.sh
```



#### 5.1.3 设置后台运行

修改配置文件，修改后重启 redis

````
vim /opt/redis/redis.conf
修改 daemonize no 为 yes
````



#### 5.1.4 设置远程访问

```
# 将 bind 注释掉
#bind 127.0.0.1
```



#### 5.1.5 修改端口和密码

```
vim /opt/redis/redis.conf
```

修改默认端口

```
将 port 6379  改为自己想要的端口
```

设置redis的密码

```
# 在配置文件中找到 requirepass
requirepass 后改为自己的密码
```

访问

```
./opt/redis/bin/redis-cli -p [端口号] -a [密码] 

# 其他操作
./opt/redis/bin/redis-cli --help
```



### 5.2 Redis 集群

#### 5.2.1 集群原理



#### 5.2.2 集群搭建



### 5.4 使用 RedisDesktopManager 访问

**下载：**

**链接：**https://pan.baidu.com/s/1Z5UGB6tisU5_Gl15FIEUTA 
**提取码：**l1bi 

**修改配置文件**

```
# 注释掉 bind
# bind 127.0.0.1

# 关闭保护模式
protected-mode no

# 记得开放防火墙和安全组端口
```



### 5.6 SpringMvc 整合 Redis

##### 引入依赖

```xml
<!-- Redis客户端 -->
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>2.9.0</version>
</dependency>
```



##### 配置文件lec

```
# 集群的访问地址
jedis.hpArrStr=www.xxx.top:7001,www.xxx.top:7002,www.xxx.top:7003,www.xxx.top:7004,www.xxx.top:7005,www.xxx.top:7006
# redis 密码，服务端没配置可以忽略
jedis.password=password
# 超时时间
jedis.timeout=3000
# 连接总数
jedis.maxTotal=30
# 最大空闲连接数
jedis.maxIdle=10
# <!-- 每次释放连接的最大数目 -->
jedis.numTestsPerEvictionRun=1024
# <!-- 释放连接的扫描间隔（毫秒） -->
jedis.timeBetweenEvictionRunsMillis=30000
# <!-- 连接最小空闲时间 -->
jedis.minEvictableIdleTimeMillis=1800000
# <!-- 连接空闲多久后释放, 当空闲时间>该值 且 空闲连接>最大空闲连接数 时直接释放 -->
jedis.softMinEvictableIdleTimeMillis=10000
# <!-- 获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1 -->
jedis.maxWaitMillis=1500
# <!-- 在获取连接的时候检查有效性, 默认false -->
jedis.testOnBorrow=true
# <!-- 在归还连接的时候检查有效性, 默认false -->
jedis.testOnReturn=true
# <!-- 在空闲时检查有效性, 默认false -->
jedis.testWhileIdle=true
# <!-- 连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true -->
jedis.blockWhenExhausted=false
# 连接重试次数
jedis.maxAttempts=3
```



##### 配置类

自己记得加 getter/setter 方法

```java
@Configuration
@PropertySource(value = {"classpath:resource/config.properties"}, ignoreResourceNotFound = true)
@Slf4j
public class JedisConfig {

    @Value("${jedis.hpArrStr}")
    private String hpArrStr;

    private List<String> hostsArr;

    private List<Integer> portsArr;

    @Value("${jedis.timeout}")
    private int timeout;

    @Value("${jedis.maxAttempts}")
    private int maxAttempts;

    @Value("${jedis.password}")
    private String password;

    // 连接总数
    @Value("${jedis.maxTotal}")
    private int maxTotal;

    // 最大空闲连接数
    @Value("${jedis.maxIdle}")
    private int maxIdle;

    // 每次释放连接的最大数目
    @Value("${jedis.numTestsPerEvictionRun}")
    private int numTestsPerEvictionRun;

    //  释放连接的扫描间隔（毫秒）
    @Value("${jedis.timeBetweenEvictionRunsMillis}")
    private int timeBetweenEvictionRunsMillis;

    //  连接最小空闲时间
    @Value("${jedis.minEvictableIdleTimeMillis}")
    private int minEvictableIdleTimeMillis;

    //  连接空闲多久后释放, 当空闲时间>该值 且 空闲连接>最大空闲连接数 时直接释放
    @Value("${jedis.softMinEvictableIdleTimeMillis}")
    private int softMinEvictableIdleTimeMillis;

    //  获取连接时的最大等待毫秒数,小于零:阻塞不确定的时间,默认-1
    @Value("${jedis.maxWaitMillis}")
    private int maxWaitMillis;

    //  在获取连接的时候检查有效性, 默认false
    @Value("${jedis.testOnBorrow}")
    private boolean testOnBorrow;

    //  在归还连接的时候检查有效性, 默认false
    @Value("${jedis.testOnReturn}")
    private boolean testOnReturn;

    //  空闲时检查有效性, 默认false
    @Value("${jedis.testWhileIdle}")
    private boolean testWhileIdle;

    //  连接耗尽时是否阻塞, false报异常,ture阻塞直到超时, 默认true
    @Value("${jedis.blockWhenExhausted}")
    private boolean blockWhenExhausted;

    @PostConstruct
    public void init() {
        if (hpArrStr != null) {
            hostsArr = new ArrayList<String>();
            portsArr = new ArrayList<Integer>();

            String[] hpList = hpArrStr.split(",");
            for (int i = 0; i < hpList.length; i++) {
                String[] node = hpList[i].split(":");
                for (int j = 0; j < node.length; j++) {
                    this.hostsArr.add(node[0]);
                    this.portsArr.add(Integer.valueOf(node[1]));
                }
            }
        }
    }

   ......
}
```



##### JedisCluster 封装

```java
@Component
public class JedisClusterClient {

    @Autowired
    private JedisConfig jedisConfig;

    private JedisCluster jedisCluster;

    @PostConstruct
    public void init() {
        HashSet<HostAndPort> nodes = new HashSet<>();
        List<String> hostsArr = jedisConfig.getHostsArr();
        List<Integer> portsArr = jedisConfig.getPortsArr();

        int len = hostsArr.size();
        for (int i = 0; i < len; i++) {
            nodes.add(new HostAndPort( hostsArr.get(i), portsArr.get(i)));
        }

        // 配置Redis信息
        JedisPoolConfig config = initPool();
        jedisCluster= new JedisCluster(nodes, jedisConfig.getTimeout(), jedisConfig.getTimeout(), 3, jedisConfig.getPassword(), config);
    }

    public JedisPoolConfig initPool() {
        // 配置Redis信息
        JedisPoolConfig config = new JedisPoolConfig();
        config.setMaxTotal(jedisConfig.getMaxTotal());
        config.setMaxIdle(jedisConfig.getMaxIdle());
        config.setMaxWaitMillis(jedisConfig.getMaxWaitMillis());
        config.setTestOnBorrow(jedisConfig.isTestOnBorrow());
        config.setTestOnReturn(jedisConfig.isTestOnReturn());
        return config;
    }

    public void close() {
        try {
            jedisCluster.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public String get(String key) {
        String string = jedisCluster.get(key);
        return string;
    }

    public String set(String key, String value) {
        System.out.println(jedisConfig.getPassword());
        String string = jedisCluster.set(key, value);
        return string;
    }

    public long incr(String key) {
        Long result = jedisCluster.incr(key);
        return result;
    }

    public Long hset(String hkey, String key, String value) {
        Long result = jedisCluster.hset(hkey, key, value);
        return result;
    }

    public String hget(String hkey, String key) {
        String string = jedisCluster.hget(hkey, key);
        return string;
    }

    public Long del(String key) {
        Long result = jedisCluster.del(key);
        return result;
    }

    public Long hdel(String hkey, String key) {
        Long result = jedisCluster.hdel(hkey, key);
        return result;
    }

    public Long expire(String key, int second) {
        Long result = jedisCluster.expire(key, second);
        return result;
    }
}	
```



### 5.7 SpringBoot 整合 Redis

##### 引入依赖

```xml
<!--redis整合springboot-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>3.2.0</version>
</dependency>

<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.3.2</version>
</dependency>

<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.5</version>
</dependency>
```



##### 修改配置文件

```properties
spring.redis.cluster.nodes=www.xxx.top:7001,www.xxx.top:7002,www.xxx.top:7003,www.xxx.top:7004,www.xxx.top:7005,www.xxx.top:7006
spring.redis.password=password
spring.redis.timeout=6000
spring.redis.cluster.max-redirects=3
spring.redis.lettuce.pool.max-active=20
spring.redis.lettuce.pool.max-idle=10
spring.redis.lettuce.pool.min-idle=1
spring.redis.lettuce.pool.max-wait=6000
```



##### 增加 RedisConfig 和 工具类

由于 redisTemplate 不是很好用，故还要封装一个工具类出来

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) {
        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<String, Object>();
        redisTemplate.setConnectionFactory(redisConnectionFactory);

        // json 序列化配置
        // https://blog.csdn.net/Farrell_zeng/article/details/107085854
        Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);
        ObjectMapper om = new ObjectMapper();
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY);
        om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
        jackson2JsonRedisSerializer.setObjectMapper(om);

        // string 的序列化
        StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();

        // 设置序列化方式
        // key 用 string 序列化，不加“”,value用json序列化
        redisTemplate.setKeySerializer(stringRedisSerializer);
        redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.setHashKeySerializer(stringRedisSerializer);
        redisTemplate.setHashValueSerializer(jackson2JsonRedisSerializer);
        redisTemplate.afterPropertiesSet();
        return redisTemplate;
    }
}
```

```java
/**
 * Redis Util
 * 操作字符串：redisTemplate.opsForValue();
 * 操作hash：redisTemplate.opsForHash();
 * 操作list：redisTemplate.opsForList();
 * 操作set：redisTemplate.opsForSet();
 * 操作有序set：redisTemplate.opsForZSet();
 */
@Component("RedisUtils")
public class RedisUtils {

    @Autowired
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 指定缓存失效时间
     *
     * @param key
     *            键
     * @param time
     *            时间(秒)
     * @return
     */
    public boolean expire(String key, long time) {
        try {
            if (time > 0) {
                redisTemplate.expire(key, time, TimeUnit.SECONDS);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据key 获取过期时间
     *
     * @param key
     *            键 不能为null
     * @return 时间(秒) 返回0代表为永久有效
     */
    public long getExpire(String key) {
        return redisTemplate.getExpire(key, TimeUnit.SECONDS);
    }

    /**
     * 判断key是否存在
     *
     * @param key
     *            键
     * @return true 存在 false不存在
     */
    public boolean hasKey(String key) {
        try {
            return redisTemplate.hasKey(key);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除缓存
     *
     * @param key
     *            可以传一个值 或多个
     */
    @SuppressWarnings("unchecked")
    public void del(String... key) {
        if (key != null && key.length > 0) {
            if (key.length == 1) {
                redisTemplate.delete(key[0]);
            } else {
                redisTemplate.delete((Collection<String>) CollectionUtils.arrayToList(key));
            }
        }
    }

    // ============================String=============================
    /**
     * 普通缓存获取
     *
     * @param key
     *            键
     * @return 值
     */
    public Object get(String key) {
        return key == null ? null : redisTemplate.opsForValue().get(key);
    }

    /**
     * 普通缓存放入
     *
     * @param key
     *            键
     * @param value
     *            值
     * @return true成功 false失败
     */
    public boolean set(String key, Object value) {
        try {
            redisTemplate.opsForValue().set(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }

    }

    /**
     * 普通缓存放入并设置时间
     *
     * @param key
     *            键
     * @param value
     *            值
     * @param time
     *            时间(秒) time要大于0 如果time小于等于0 将设置无限期
     * @return true成功 false 失败
     */
    public boolean set(String key, Object value, long time) {
        try {
            if (time > 0) {
                redisTemplate.opsForValue().set(key, value, time, TimeUnit.SECONDS);
            } else {
                set(key, value);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 递增
     *
     * @param key
     *            键
     * @param delta
     *            要增加几(大于0)
     * @return
     */
    public long incr(String key, long delta) {
        if (delta < 0) {
            throw new RuntimeException("递增因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, delta);
    }

    /**
     * 递减
     *
     * @param key
     *            键
     * @param delta
     *            要减少几(小于0)
     * @return
     */
    public long decr(String key, long delta) {
        if (delta < 0) {
            throw new RuntimeException("递减因子必须大于0");
        }
        return redisTemplate.opsForValue().increment(key, -delta);
    }

    // ================================Map=================================
    /**
     * HashGet
     *
     * @param key
     *            键 不能为null
     * @param item
     *            项 不能为null
     * @return 值
     */
    public Object hget(String key, String item) {
        return redisTemplate.opsForHash().get(key, item);
    }

    /**
     * 获取hashKey对应的所有键值
     *
     * @param key
     *            键
     * @return 对应的多个键值
     */
    public Map<Object, Object> hmget(String key) {
        return redisTemplate.opsForHash().entries(key);
    }

    /**
     * HashSet
     *
     * @param key
     *            键
     * @param map
     *            对应多个键值
     * @return true 成功 false 失败
     */
    public boolean hmset(String key, Map<String, Object> map) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * HashSet 并设置时间
     *
     * @param key
     *            键
     * @param map
     *            对应多个键值
     * @param time
     *            时间(秒)
     * @return true成功 false失败
     */
    public boolean hmset(String key, Map<String, Object> map, long time) {
        try {
            redisTemplate.opsForHash().putAll(key, map);
            if (time > 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key
     *            键
     * @param item
     *            项
     * @param value
     *            值
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 向一张hash表中放入数据,如果不存在将创建
     *
     * @param key
     *            键
     * @param item
     *            项
     * @param value
     *            值
     * @param time
     *            时间(秒) 注意:如果已存在的hash表有时间,这里将会替换原有的时间
     * @return true 成功 false失败
     */
    public boolean hset(String key, String item, Object value, long time) {
        try {
            redisTemplate.opsForHash().put(key, item, value);
            if (time > 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 删除hash表中的值
     *
     * @param key
     *            键 不能为null
     * @param item
     *            项 可以使多个 不能为null
     */
    public void hdel(String key, Object... item) {
        redisTemplate.opsForHash().delete(key, item);
    }

    /**
     * 判断hash表中是否有该项的值
     *
     * @param key
     *            键 不能为null
     * @param item
     *            项 不能为null
     * @return true 存在 false不存在
     */
    public boolean hHasKey(String key, String item) {
        return redisTemplate.opsForHash().hasKey(key, item);
    }

    /**
     * hash递增 如果不存在,就会创建一个 并把新增后的值返回
     *
     * @param key
     *            键
     * @param item
     *            项
     * @param by
     *            要增加几(大于0)
     * @return
     */
    public double hincr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, by);
    }

    /**
     * hash递减
     *
     * @param key
     *            键
     * @param item
     *            项
     * @param by
     *            要减少记(小于0)
     * @return
     */
    public double hdecr(String key, String item, double by) {
        return redisTemplate.opsForHash().increment(key, item, -by);
    }

    // ============================set=============================
    /**
     * 根据key获取Set中的所有值
     *
     * @param key
     *            键
     * @return
     */
    public Set<Object> sGet(String key) {
        try {
            return redisTemplate.opsForSet().members(key);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 根据value从一个set中查询,是否存在
     *
     * @param key
     *            键
     * @param value
     *            值
     * @return true 存在 false不存在
     */
    public boolean sHasKey(String key, Object value) {
        try {
            return redisTemplate.opsForSet().isMember(key, value);
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将数据放入set缓存
     *
     * @param key
     *            键
     * @param values
     *            值 可以是多个
     * @return 成功个数
     */
    public long sSet(String key, Object... values) {
        try {
            return redisTemplate.opsForSet().add(key, values);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 将set数据放入缓存
     *
     * @param key
     *            键
     * @param time
     *            时间(秒)
     * @param values
     *            值 可以是多个
     * @return 成功个数
     */
    public long sSetAndTime(String key, long time, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().add(key, values);
            if (time > 0) {
                expire(key, time);
            }
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 获取set缓存的长度
     *
     * @param key
     *            键
     * @return
     */
    public long sGetSetSize(String key) {
        try {
            return redisTemplate.opsForSet().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 移除值为value的
     *
     * @param key
     *            键
     * @param values
     *            值 可以是多个
     * @return 移除的个数
     */
    public long remove(String key, Object... values) {
        try {
            Long count = redisTemplate.opsForSet().remove(key, values);
            return count;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
    // ===============================list=================================

    /**
     * 获取list缓存的内容
     *
     * @param key
     *            键
     * @param start
     *            开始
     * @param end
     *            结束 0 到 -1代表所有值
     * @return
     */
    public List<Object> lGet(String key, long start, long end) {
        try {
            return redisTemplate.opsForList().range(key, start, end);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 获取list缓存的长度
     *
     * @param key
     *            键
     * @return
     */
    public long lGetListSize(String key) {
        try {
            return redisTemplate.opsForList().size(key);
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }

    /**
     * 通过索引 获取list中的值
     *
     * @param key
     *            键
     * @param index
     *            索引 index>=0时， 0 表头，1 第二个元素，依次类推；index<0时，-1，表尾，-2倒数第二个元素，依次类推
     * @return
     */
    public Object lGetIndex(String key, long index) {
        try {
            return redisTemplate.opsForList().index(key, index);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key
     *            键
     * @param value
     *            值
     * @return
     */
    public boolean lSet(String key, Object value) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key
     *            键
     * @param value
     *            值
     * @param time
     *            时间(秒)
     * @return
     */
    public boolean lSet(String key, Object value, long time) {
        try {
            redisTemplate.opsForList().rightPush(key, value);
            if (time > 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key
     *            键
     * @param value
     *            值
     * @return
     */
    public boolean lSet(String key, List<Object> value) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 将list放入缓存
     *
     * @param key
     *            键
     * @param value
     *            值
     * @param time
     *            时间(秒)
     * @return
     */
    public boolean lSet(String key, List<Object> value, long time) {
        try {
            redisTemplate.opsForList().rightPushAll(key, value);
            if (time > 0) {
                expire(key, time);
            }
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 根据索引修改list中的某条数据
     *
     * @param key
     *            键
     * @param index
     *            索引
     * @param value
     *            值
     * @return
     */
    public boolean lUpdateIndex(String key, long index, Object value) {
        try {
            redisTemplate.opsForList().set(key, index, value);
            return true;
        } catch (Exception e) {
            e.printStackTrace();
            return false;
        }
    }

    /**
     * 移除N个值为value
     *
     * @param key
     *            键
     * @param count
     *            移除多少个
     * @param value
     *            值
     * @return 移除的个数
     */
    public long lRemove(String key, long count, Object value) {
        try {
            Long remove = redisTemplate.opsForList().remove(key, count, value);
            return remove;
        } catch (Exception e) {
            e.printStackTrace();
            return 0;
        }
    }
}

```



##### 测试

```java
@SpringBootTest
public class JedisTest {

    @Autowired
    private RedisUtils redisUtils;

    @Test
    public void test() {
        RedisUtils.set("aa", "1000");
        System.out.println(redisUtils.get("aa"));
    }
}
```





### 5.8 报错记录

##### 5.8.1 (error) MOVED 15495 127.0.0.1:7003

这是由于 redis 对 key 进行计算后，发现当前 key 在其他节点的槽上

节点会对命令请求进行分析和key的slot计算，并且会查找这个命令所要处理的键所在的槽。如果要查找的哈希槽正好就由接收到命令的节点负责处理， 那么节点就直接执行这个命令

另一方面， 如果所查找的槽不是由该节点处理的话， 节点将查看自身内部所保存的哈希槽到节点 ID 的映射记录， 并向客户端回复一个 MOVED 错误。上面的错误信息包含键 x 所属的哈希槽15495， 以及负责处理这个槽的节点的 IP 和端口号 127.0.0.1:7003

通过这样的撇皮，客户端就可以加快寻找正确节点的速度。这样，当集群处于稳定状态时，所有客户端最终都会保存有一个哈希槽至节点的映射记录，使得集群非常高效

可以在访问时使用 -c 重定向，如

```
./redis-cli -p 7001 -a password -c 2>/dev/null
```



##### 5.8.2 提示 JedisConnectionException: Could not get a resource from the pool

出现这种情况有几种可能：

1）检查防火墙和安全组是否开放

2）检查 node.conf 下自动生成的Ip是否正确

通过跟踪代码，发现 node.conf 下存在内网Ip的情况，猜测是和 redis 版本有关系(当前用的5.0.3)

将内网Ip改为服务器的外网Ip，再次连接，连接正常了



##### 5.8.3 阿里云服务器节点ip出现内网ip

修改 node.conf，手动将内网ip 改为公网ip，杀死进程后重启



## 六、SwaggerUI

### 6.1 SpringMVC 整合 SwaggerUI

**引入依赖**

```xml
<!-- Spring -->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context</artifactId>
    <version>${spring.version}</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-beans</artifactId>
    <version>${spring.version}</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>${spring.version}</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-jdbc</artifactId>
    <version>${spring.version}</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>${spring.version}</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-context-support</artifactId>
    <version>${spring.version}</version>
</dependency>

<!-- SwaggerUI -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.4.0</version>
</dependency>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.4.0</version>
</dependency>
```



**在 springmvc.xml 中配置**

```xml
<!-- Swagger支持（暂时注释掉提高平台性能，需要此功能，可以放开注释）-->
<context:component-scan base-package="springfox"/>
<mvc:resources mapping="/swagger/**" location="/swagger/"/>
<!-- 避免IE执行AJAX时,返回JSON出现下载文件 -->
<bean id="mappingJacksonHttpMessageConverter" class="org.springframework.http.converter.json.MappingJackson2HttpMessageConverter">
    <property name="supportedMediaTypes">
        <list>
            <value>text/html;charset=UTF-8</value>
            <value>text/json;charset=UTF-8</value>
            <value>application/json;charset=UTF-8</value>
        </list>
    </property>
</bean>
<!-- ResponseBody返回字符串带双引号解决 -->
<bean id="stringHttpMessageConverter" class="org.springframework.http.converter.StringHttpMessageConverter">
    <constructor-arg value="UTF-8" index="0"/>
    <property name="supportedMediaTypes">
        <list>
            <value>text/plain;charset=UTF-8</value>
        </list>
    </property>
</bean>
<!-- 注册handler method和request的mapping关系。  -->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
<!-- 启动Spring MVC的注解功能，完成请求和注解POJO的映射， 配置一个基于注解的定制的WebBindingInitializer，解决日期转换问题，方法级别的处理器映射 -->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
    <property name="cacheSeconds" value="0"/>
    <property name="messageConverters">
        <list>
            <ref bean="stringHttpMessageConverter"/> <!--先进行string转换-->
            <ref bean="mappingJacksonHttpMessageConverter"/><!-- json转换器 -->
        </list>
    </property>
</bean>
```



**增加配置文件类**，记得要在 springmvc 扫描包时也扫描这个类

```java
@Configuration
@EnableSwagger2
public class SwaggerConfig {
    @Bean
    public Docket api() {
        return new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(apiInfo())
//                .pathMapping("/rest/")//对请求的路径增加rest前缀
                .globalOperationParameters(setHeaderToken())
                .select()
                .apis(RequestHandlerSelectors.withMethodAnnotation(ApiOperation.class)) //只过滤包含有ApiOperation注解的方法
                .paths(PathSelectors.any()) //对所有的路径进行监控
                .build();
    }

    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("upload-platform")
                .description("a platform to upload file")
                .version("1.1.0")
                .build();
    }

    private List<Parameter> setHeaderToken() {
        ParameterBuilder tokenPar = new ParameterBuilder();
        List<Parameter> pars = new ArrayList<>();
        tokenPar.name("X-AUTH-TOKEN").description("token").modelRef(new ModelRef("string")).parameterType("header").required(false).build();
        pars.add(tokenPar.build());
        return pars;
    }
}
```



**swagger-ui 界面文件存放：**

在 webapp 下创建 swagger 文件夹，将相关的文件全部放进去，其实是与 springmvc.xml 中的路径相匹配

**官网地址：**

https://github.com/swagger-api/swagger-ui

**v2.x:**

链接：https://pan.baidu.com/s/1fai6yA_wSr2an_ZAN85BAA 
提取码：fpgx 
v3.x



**访问：**

运行项目后，先访问到页面

如： http://localhost:8081/swagger/index.html

搜索框内输入： /v2/api-docs



### 6.2 SpringMVC 整合 Knife4j

Knife4j 说对 SwaggerUI 的扩展，有更美观和便捷的界面展示

https://doc.xiaominfo.com/knife4j/action/springmvc.html

###### **引入依赖**

```xml
<!--引入Knife4j-->
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-mvc</artifactId>
    <!--在引用时请在maven中央仓库搜索最新版本号，如果不存在则代表尚未发布,作者正在努力开发中-->
    <version>2.0.8</version>
</dependency>
<dependency>
    <groupId>javax.websocket</groupId>
    <artifactId>javax.websocket-api</artifactId>
    <version>1.0</version>
    <scope>provided</scope>
</dependency>
<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-validator -->
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.0.10.Final</version>
</dependency>
<!-- https://mvnrepository.com/artifact/com.google.code.gson/gson -->
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.8.2</version>
</dependency>

<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>

<dependency>
    <groupId>jstl</groupId>
    <artifactId>jstl</artifactId>
    <version>1.2</version>
</dependency>

<dependency>
    <groupId>commons-fileupload</groupId>
    <artifactId>commons-fileupload</artifactId>
    <version>1.3.1</version>
</dependency>

<!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpasyncclient -->
<dependency>
    <groupId>org.apache.httpcomponents</groupId>
    <artifactId>httpasyncclient</artifactId>
    <version>4.1.4</version>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.3.2</version>
</dependency>
<!-- https://mvnrepository.com/artifact/cn.hutool/hutool-all -->
<dependency>
    <groupId>cn.hutool</groupId>
    <artifactId>hutool-all</artifactId>
    <version>4.1.19</version>
</dependency>
```



###### **修改 web.xml**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <display-name>uploadPlatUser</display-name>
    <context-param>
        <param-name>webAppRootKey</param-name>
        <param-value>upload-user.root</param-value>
    </context-param>

    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:spring/applicationContext-*.xml</param-value>
    </context-param>
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <context-param>
        <param-name>logbackConfigLocation</param-name>
        <param-value>classpath:logback.xml</param-value>
    </context-param>
    <listener>
        <listener-class>ch.qos.logback.ext.spring.web.LogbackConfigListener</listener-class>
    </listener>


    <!-- 解决post乱码 -->
    <filter>
        <filter-name>CharacterEncodingFilter</filter-name>
        <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
        <init-param>
            <param-name>encoding</param-name>
            <param-value>utf-8</param-value>
        </init-param>
        <init-param>
            <param-name>forceEncoding</param-name>
            <param-value>true</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>CharacterEncodingFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!--SwaggerBootstrapUi提供的Swagger增强功能,Filter过滤保护Swagger资源-->
    <!--生产环境Filter-->
    <filter>
        <filter-name>knife4jProductionFilter</filter-name>
        <filter-class>com.github.xiaoymin.knife4j.spring.filter.ProductionSecurityFilter</filter-class>
        <init-param>
            <param-name>production</param-name>
            <param-value>false</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>knife4jProductionFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    <!--Swagger资源的Basic认证保护策略-->
    <filter>
        <filter-name>knife4jSecurityBasic</filter-name>
        <filter-class>com.github.xiaoymin.knife4j.spring.filter.SecurityBasicAuthFilter</filter-class>
        <!--开启basic认证-->
        <init-param>
            <param-name>enableBasicAuth</param-name>
            <param-value>false</param-value>
        </init-param>
        <!--用户名&密码-->
        <init-param>
            <param-name>userName</param-name>
            <param-value>lisi</param-value>
        </init-param>
        <init-param>
            <param-name>password</param-name>
            <param-value>123</param-value>
        </init-param>
    </filter>
    <filter-mapping>
        <filter-name>knife4jSecurityBasic</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

    <!-- springmvc的前端控制器 -->
    <servlet>
        <servlet-name>uploadPlatUser</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- contextConfigLocation不是必须的， 如果不配置contextConfigLocation， springmvc的配置文件默认在：WEB-INF/servlet的name+"-servlet.xml" -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>classpath:spring/springmvc.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <!-- 配置knife4j的url请求路径-->
    <servlet-mapping>
        <servlet-name>uploadPlatUser</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>uploadPlatUser</servlet-name>
        <url-pattern>/v2/api-docs</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>uploadPlatUser</servlet-name>
        <url-pattern>/swagger-resources</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>uploadPlatUser</servlet-name>
        <url-pattern>/v2/api-docs-ext</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>uploadPlatUser</servlet-name>
        <url-pattern>/swagger-resources/configuration/ui</url-pattern>
    </servlet-mapping>
    <servlet-mapping>
        <servlet-name>uploadPlatUser</servlet-name>
        <url-pattern>/swagger-resources/configuration/security</url-pattern>
    </servlet-mapping>
    <welcome-file-list>
        <welcome-file>index.htm</welcome-file>
    </welcome-file-list>
</web-app>
```



###### 修改 springmvc.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context-4.2.xsd
        http://www.springframework.org/schema/mvc">
    <context:property-placeholder location="classpath:config.properties" ignore-unresolvable="true"/>

    <context:component-scan base-package="com.upload.user.controller;com.upload.user.swagger;com.upload.common">
        <!-- 设置注解扫描目录 -->
        <context:include-filter type="annotation" expression="org.springframework.stereotype.Controller"/>
    </context:component-scan>
    <mvc:resources location="classpath:/META-INF/resources/" mapping="doc.html"/>
    <mvc:resources location="classpath:/META-INF/resources/webjars/" mapping="/webjars/**"/>

    <bean id="jspViewResolver"
          class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="viewClass"
                  value="org.springframework.web.servlet.view.JstlView" />
        <property name="prefix" value="/WEB-INF/jsp/" />
        <property name="suffix" value=".jsp" />
    </bean>

    <bean
            class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter">
        <property name="messageConverters">
            <list>
                <bean
                        class="org.springframework.http.converter.StringHttpMessageConverter">
                    <property name="supportedMediaTypes">
                        <list>
                            <value>text/json;charset=utf-8</value>
                            <value>application/json;charset=utf-8</value>
                        </list>
                    </property>
                </bean>
            </list>
        </property>
    </bean>

    <mvc:annotation-driven enable-matrix-variables="true" >
    </mvc:annotation-driven>
    <!-- 上传文件拦截，设置最大上传文件大小 100M=100*1024*1024(B)=10485760 bytes -->
    <bean id="multipartResolver"
          class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
        <property name="maxUploadSize" value="104857600" />
    </bean>
</beans>
```



###### 写配置类 SwaggerConfiguration.class

basePackage 记得改成当前项目的 controller，否则会不显示接口内容

```java
@Configuration
@EnableSwagger2WebMvc
@EnableKnife4j
@Import(BeanValidatorPluginsConfiguration.class)
public class SwaggerConfiguration {
    @Bean
    public Docket defaultApi() {
        String groupName = "文件上传平台v1.0";
        return new Docket(DocumentationType.SWAGGER_2)
                // 添加全局响应状态码
                .apiInfo(groupApiInfo())
                .groupName(groupName)
                .useDefaultResponseMessages(false)
                .select()
                .apis(RequestHandlerSelectors.basePackage("com.upload.user"))
                .paths(PathSelectors.any())
                .build();
    }


    private ApiInfo groupApiInfo() {
        return new ApiInfoBuilder()
                .title("文件上传平台文档")
                .description("文件上传平台 restApi 文档")
                .termsOfServiceUrl("http://www.baidu.com")
                .version("1.0")
                .build();
    }
}
```



###### 访问

根据实际情况修改地址和端口

http://www.xxxx.com:8080/doc.html



### 6.3 SpringBoot 整合 Knife4j

引入依赖

```xml
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-boot-starter</artifactId>
    <version>2.0.8</version>
</dependency>
```



在配置文件 application.yml 中增加

https://doc.xiaominfo.com/knife4j/documentation/enhance.html

```properties
knife4j:
  enable: true
  documents:
      group: 文件上传平台v1.0-用户服务
      name: tom
      locations: classpath:sign/*
  setting:
    language: zh-CN
    enableSwaggerModels: true
    enableDocumentManage: true
    enableAfterScript: true
    enableFilterMultipartApis: false
    enableRequestCache: true
    enableHomeCustom: true
    enableDynamicParameter: true
    enableGroup: true
  production: false
  basic:
    enable: false
    username: test
    password: 12313
```



增加配置类

```java
import com.github.xiaoymin.knife4j.spring.annotations.EnableKnife4j;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import springfox.documentation.builders.ApiInfoBuilder;
import springfox.documentation.builders.PathSelectors;
import springfox.documentation.builders.RequestHandlerSelectors;
import springfox.documentation.service.ApiInfo;
import springfox.documentation.spi.DocumentationType;
import springfox.documentation.spring.web.plugins.Docket;
import springfox.documentation.swagger2.annotations.EnableSwagger2WebMvc;

@Configuration
@EnableSwagger2WebMvc
public class Knife4jConfig {

    @Bean
    public Docket defaultApi() {
        String groupName = "文件上传平台v1.0";
        Docket docket=new Docket(DocumentationType.SWAGGER_2)
                .apiInfo(groupApiInfo())
                //分组名称
                .groupName(groupName)
                .useDefaultResponseMessages(false)
                .select()
                //这里指定Controller扫描包路径
                .apis(RequestHandlerSelectors.basePackage("com.upload.user"))
                .paths(PathSelectors.any())
                .build();
        return docket;
    }

    private ApiInfo groupApiInfo() {
        return new ApiInfoBuilder()
                .title("文件上传平台文档")
                .description("文件上传平台 restApi 文档")
                .termsOfServiceUrl("http://www.baidu.com")
                .version("1.0")
                .build();
    }
}
```



### 6.4 与前端交互

应该把项目部署到对应服务器去，让前端访问页面



### 6.5 注解详解

#### 6.5.1  @Api 模块标识

用于标注一个模块，实现 restApi 的分类

```java
@Api(tags = "用户模块")
public class UserController {
	...
}
```



#### 6.5.2  @ApiOperation 描述http请求相关

value: 用户在界面上可以看到 /login 以及 value 内的描述字段，而 response 和 notes 则是用户点开具体的某个 api 才会展示

```java
@RequestMapping("/login")
@ApiOperation(value = "用户登录", httpMethod = "POST", notes = "用户输入账号密码登录平台", produces = "application/json", response = ResData.class)
@ApiOperationSupport(
        order = 1,
        author = "tom",
        includeParameters = {"user.account","user.password"}
)
public ResData doLogin(@RequestBody User user) {
    ResData r = userService.doLogin(user.getAccount(), user.getPassword());
    return r;
}

@RequestMapping("/forget")
@ApiOperation(value = "忘记密码", httpMethod = "POST", notes = "用户忘记密码，通过账号密码找回", produces = "application/json", response = ResData.class)
@ApiOperationSupport(
        order = 2,
        author = "tom"
)
public ResData forget(@RequestBody UserVO regUserVO) {
    ResData r = userService.doForget(regUserVO.getAccount(), regUserVO.getNewPassword());
    return r;
}
```



#### 6.5.3  @ApiModel 实体类描述

用于描述实例类，而 @ApiModelProperty 则是用于描述实体类的属性

```java
@Table(name = "user")
@ApiModel(description = "用户")
public class User {
    @Id
    private Long id;

    /**
     * 用户id
     */
    @ApiModelProperty(value = "用户id")
    private String userId;

    /**
     * 用户账号
     */
    @ApiModelProperty(value = "用户账号")
    private String account;

    /**
     * 用户密码
     */
    @ApiModelProperty(value = "用户密码")
    private String password;

    /**
     * 用户昵称
     */
    @ApiModelProperty(value = "用户昵称")
    private String username;

    /**
     * 用户头像地址
     */
    @ApiModelProperty(value = "用户头像地址")
    private String avatar;

    /**
     * 用户状态 0 正常 1 冻结 2 注销
     */
    @ApiModelProperty(value = "用户状态 0 正常 1 冻结 2 注销")
    private Integer state;

    /**
     * 创建时间
     */
    @ApiModelProperty(value = "创建时间")
    private Date created;

    /**
     * 更新时间
     */
    @ApiModelProperty(value = "更新时间")
    private Date updated;

    ......
}
```



#### 6.5.4 状态码设置

由于 swaggerui 只提供了 http 响应码，不允许自定义状态码，故有两种方式设置状态码

1） 直接复制响应码类到文档中

2）定义一个状态码类，并加入到 model 中



##### **自定义状态码类**

###### 响应类 ResData.java

```java
@ApiModel(description = "返回类型")
public class ResData {
    // 定义jackson对象
    private static final ObjectMapper MAPPER = new ObjectMapper();

    // 响应状态码
    @ApiModelProperty(value = "状态码，具体类型看 ResCode", dataType="int")
    private int code;
    // 响应消息
    @ApiModelProperty(value = "描述消息", dataType="String")
    private String message;
    // 响应数据
    @ApiModelProperty(value = "响应数据", dataType="Object")
    private Object data;

    public ResData(String msg) {
        this.code = ResCode.C().OK;
        this.message = msg;
        this.data = null;
    }

    public ResData(Object data) {
        this.code = ResCode.C().OK;
        this.message = "";
        this.data = data;
    }

    public ResData(int code, String message, Object data) {
        this.code = code;
        this.message = message;
        this.data = data;
    }

    public static ResData build(Integer status, String msg, Object data) {
        return new ResData(status, msg, data);
    }

    public static ResData success() {
        return new ResData(null);
    }

    public static ResData success(String sucMsg) {
        return new ResData(sucMsg);
    }

    public static ResData success(Object data) {
        return new ResData(data);
    }

    public static ResData error(String errorMsg) {
        return new ResData(ResCode.C().ERROR, errorMsg, null);
    }

    public static ResData error(int code, String errorMsg) {
        return new ResData(code, errorMsg, null);
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public Object getData() {
        return data;
    }

    public void setData(Object data) {
        this.data = data;
    }


    /**
     * Object是集合转化
     *
     * @param jsonData json数据
     * @param clazz 集合中的类型
     * @return
     */
    public static ResData formatToList(String jsonData, Class<?> clazz) {
        try {
            JsonNode jsonNode = MAPPER.readTree(jsonData);
            JsonNode data = jsonNode.get("data");
            Object obj = null;
            if (data.isArray() && data.size() > 0) {
                obj = MAPPER.readValue(data.traverse(),
                        MAPPER.getTypeFactory().constructCollectionType(List.class, clazz));
            }
            return build(jsonNode.get("status").intValue(), jsonNode.get("msg").asText(), obj);
        } catch (Exception e) {
            return null;
        }
    }

    @Override
    public String toString() {
        return "R{" +
                "code=" + code +
                ", message='" + message + '\'' +
                ", data=" + data.toString() +
                '}';
    }
}
```



###### **定义状态码类**

```java
@ApiModel(description = "自定义响应状态码")
public class ResCode {

    // 请求成功
    @ApiModelProperty(name = "0", value = "(0) 请求成功")
    public int OK = 0;

    // 失败
    @ApiModelProperty(name = "-1", value = "(-1) 请求失败")
    public int ERROR = -1;

    public static ResCode C() {
        return new ResCode();
    }
}
```

**使用**

```java
public ResData doLogin(String account, String password) {
    Example userExample = new Example(User.class);
    Example.Criteria criteria = userExample.createCriteria();
    criteria.andEqualTo("account", account);
    List<User> users = userMapper.selectByExample(userExample);
    if (users==null || users.size() == 0) {
        return ResData.error(ResCode.C().ERROR, ResMsg.USER_ACCOUNT_NOTEXIST);
    }

    User user = users.get(0);
    if (password.equals(user.getPassword())) {
        return ResData.success(ResMsg.USER_LOGIN_SUC);
    }   else {
        return ResData.error(ResCode.C().ERROR, ResMsg.USER_PWD_ERROR);
    }
}
```



### 6.6 示例代码

```java
@Controller
@RequestMapping("/rest/user")
@ResponseBody
@Api(tags = "用户模块")
public class UserController {
    @Autowired
    private JedisClusterClient jedisClusterClient;

    @Autowired
    private UserService userService;

    @Autowired
    private IdWorker idWorker;

    @Autowired
    private JwtUtil jwtUtil;

    @RequestMapping("/login")
    @ApiOperation(value = "用户登录", httpMethod = "POST", notes = "用户输入账号密码登录平台", produces = "application/json")
    @ApiOperationSupport(order = 2, author = "tom",
            includeParameters = {"u.account","u.password"}
    )
    @RestIgnoreAnon
    public ResData<LoginVo> doLogin(@RequestBody User u) {
        User user= userService.selectByAccount(u.getAccount());
        // 若用户为空
        if(user == null) {
            return ResData.error(ResCode.C().ERROR, ResMsg.USER_ACCOUNT_NOTEXIST);
        }

        // 判断密码是否正确
        if (u.getPassword().equals(user.getPassword())) {
            // 生成 token
            String randomKey = TokenUtils.generateValue();
            String token = jwtUtil.generateToken(u.getAccount(),
                    String.valueOf(user.getId()), randomKey);

            // 存储并返回
            LoginVo loginVo = new LoginVo(user.getId(), token, user.getUsername(), user.getAvatar(), user.getUserId());

            return new ResData(ResCode.C().OK, ResMsg.USER_LOGIN_SUC, loginVo);
        }   else {
            return ResData.error(ResCode.C().ERROR, ResMsg.USER_PWD_ERROR);
        }
    }

    @RequestMapping("/register")
    @ApiOperation(value = "用户注册", httpMethod = "POST", notes = "用户注册22")
    @ApiOperationSupport(order = 3, author = "tom",
            includeParameters = {"user.account","user.password","user.avatar","user.username"}
    )
    @RestIgnoreAnon
    public ResData doReigster(@RequestBody User user) {
        User newUser = new User();
        newUser.setAccount(user.getAccount());
        newUser.setPassword(user.getPassword());
        newUser.setAvatar(user.getAvatar());
        newUser.setUsername(user.getUsername());
        newUser.setState(CState.ACTIVE);
        newUser.setCreated(new Date());
        newUser.setUpdated(new Date());
        newUser.setUserId(String.valueOf(idWorker.nextId()));
        ResData r = userService.doRegister(newUser);
        return r;
    }

    @RequestMapping("/forget")
    @ApiOperation(value = "忘记密码", httpMethod = "POST", notes = "用户忘记密码，通过账号密码找回", produces = "application/json")
    @ApiOperationSupport(order = 4, author = "tom")
    @RestIgnoreAnon
    public ResData forget(@RequestBody UserVO regUserVO) {
        ResData r = userService.doForget(regUserVO);
        return r;
    }

    @RequestMapping("/onlyTestCode")
    @ApiOperation(value = "响应状态码查看", httpMethod = "POST")
    @ApiOperationSupport(order = 1)
    @RestIgnoreAnon
    public ResCode onlyTestCode() {
        return new ResCode();
    }
}

```



## 七、JWT

### 7.1 简介

#### token

token 即令牌，主要用于解决用户请求的权限验证以及登录超时处理。

一般流程是：用户在成功登录后服务器响应一个 token 给前端，之后前端的接口请求都要带上这个 token(header 或 body 中)。后端接收到这些请求后，需要在过滤器中先验证一下 token 是否有效且未过期，若满足则执行函数处理，不满足则返回 token 为空/过期。



#### JWT

JWT全称为Json Web Token，主要用于解决 token 不携带用户信息，每次请求都需要去请求认证服务器验证 token ，这会极大增加认证服务的压力。 而 JWT 实现了数据本地化，token 可以在各个服务模块自行验证码，而不用每次请求认证服务器



#### 特点

- **无状态**
  - jwt 不在服务端存储任何状态，应用可以直接从载荷中获取到常用信息
- **扩展性好**
  - 由于 jwt 是无状态的，本身已经保存了用户的部分数据，因此不同的服务获取到 jwt 后可以直接解析内容。因此不会对服务扩展造成影响
- **一次性**
  - jwt 是一次性的，无法修改里面的内容，若要修改，必须签发一个新的 jwt。由此会导致 jwt 令牌无法续签，以及 jwt 令牌无法废弃的问题，因此一般结合 redis 使用
- **性能**
  - 由于编码后的 jwt 太长，会导致开销更大



#### 适用场景

api 鉴权，身份认证



### 7.2 原理

####  jwt 结构

一个 jwt 实际是一个字符串，由三个部分构成：头部、载荷、签名

###### **Header 头部**

头部用于描述关于该 JWT 的最基本信息，例如它的类型以及签名所用的算法等，这一部分被可以被表示成一个 JSON 对象。

```json
{"typ":"JWT", "alg":"HS256"}
```

这段 JSON 字符串指明了签名算法是 HS256 算法，实际使用中这段字符串会被 base64编码，被编码后的字符串为：

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9
```



###### **Payload 载荷**

载荷是存放有效信息的地方，内部包含的数据称为声明。虽然可以存放数据，但不要存放未加密的敏感数据信息。

声明有三种类型：

- Registered claims : 这里有一组预定义的声明，它们不是强制的，但是推荐。比如：iss (issuer), exp (expiration time), sub (subject), aud (audience)等。
- Public claims : 公共的声明可以添加任何信息，一般添加用户的相关信息或其他业务需要的必要信息，但由于这部分信息在客户端可以被解密，设置这部分可以不加密，故不建议添加敏感信息。这部分信息不参与令牌校验。
- Private claims : 私有声明是提供者和消费者共同定义的声明，由于 base64是对称解密，即这部分信息可以被解密，故不建议存放敏感信息。这部分信息不参与令牌校验。

| **声明名称** | **作用**                                                   |
| ------------ | ---------------------------------------------------------- |
| iss          | jwt 的签发者                                               |
| sub          | 当前令牌的描述说明                                         |
| aud          | 接收 jwt 的一方                                            |
| exp          | jwt 的过期时间，这个时间必须大于签发时间                   |
| nbf          | 定义在什么时间之前，这个 jwt 是不可用的                    |
| iat          | jwt 的签发时间                                             |
| jti          | jwt 的唯一身份标识，主要用来作为一次性 token，避免重放攻击 |



###### Signature 签名

签名是为了校验数据在传输过程中是否被篡改，并且，对于使用私钥签名的token，它还可以验证JWT的发送方是否真的是它所称的发送方



**形成**

签名信息由三部分组成：

- header(base64后的)
- payload(base64后的)
- secret (秘钥，或称盐)



**签名的生成方式是：**

Base64(Header) . Base64(Payload) + 秘钥(盐) => 加密(使用 Header 中指定的算法加密) => 密文(签名)

例如(数据不准确)：

Base64(Header)为：eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9

Base64(Payload)为：eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9

secret为： abcdefg

则签名为： 

```
HS256(

​      eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.

​       eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.

​       abcdefg

) => **TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ**
```

最后生成的 jwt 为：

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```



###### **注意**

**安全性**

secret 是保存在服务器端的， jwt 的签发也是发生在服务器端，可以认为 secret 就是服务器端用于签名的私钥，在任何场景中都不应该泄漏出去，一旦客户端得知这个 secret，它就可以自我签发 jwt 了

**防篡改**

同时 secret 仅保存在服务器，若篡改了 jwt，则签名部分肯定发生了变化，服务器只要对比签名部分就能判断出 jwt 是否被篡改了



#### 签发流程和验证

 签发流程：



### 7.3 Springmvc 整合 jwt + jedis

#### 引入依赖

```xml
<!-- jwt -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.9.1</version>
</dependency>

<dependency>
    <groupId>commons-codec</groupId>
    <artifactId>commons-codec</artifactId>
    <version>1.10</version>
</dependency>

<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
```



#### 创建jwt配置类 JwtConfig.java

```java
@Configuration
@PropertySource(value = {"classpath:config.properties"}, ignoreResourceNotFound = true)
public class JwtConfig {
    /**
     * jwt密钥
     */
    @Value("${jwt.secret}")
    private String secret;

    /**
     * md5加密混淆key
     */
    @Value("${jwt.md5Key}")
    private String md5Key;

    /**
     * 过期时间：一小时 s（单位：秒）
     */
    @Value("${jwt.expiration}")
    private Long expiration;

    @Value("${jwt.iss}")
    private String iss;

    ... 记得自己生成 get set 方法
}

```



#### 给 config.properties增加变量

```properties
######################## jwt
jwt.secret="tom-upload" // 加密秘钥
jwt.md5Key="randomKey" // md5加密
jwt.expiration=60000 // 令牌过期时间
jwt.iss="tom" // 签发人
```



#### 增加 JwtUtil.java

```java
/**
 * JWT工具类
 */
@Component
public class JwtUtil {

    @Autowired
    private JwtConfig jwtConfig;
    /**
     * 获取用户名
     * @param token
     * @return
     */
    public String getUsername(String token) {
        return getClaims(token).getSubject();
    }

    /**
     * 创建时间
     * @param token
     * @return
     */
    public Date getCreateDate(String token) {
        return getClaims(token).getIssuedAt();
    }

    /**
     * 过期时间
     * @param token
     * @return
     */
    public Date getExpireDate(String token) {
        return getClaims(token).getExpiration();
    }

    /**
     * token接收者
     * @param token
     * @return
     */
    public String getUserId(String token) {
        return getClaims(token).getAudience();
    }

    /**
     * 获取md5混淆的key
     * @param token
     * @return
     */
    public String getMd5Key(String token) {
        return getPrivateClaims(token, jwtConfig.getMd5Key());
    }

    /**
     * 获取私有的claims
     * @param token
     * @param key
     * @return
     */
    private String getPrivateClaims(String token, String key) {
        return getClaims(token).get(key).toString();
    }

    /**
     * 获取payload
     * @param token
     * @return
     */
    private Claims getClaims(String token) {
        return Jwts.parser()
                .setSigningKey(getSecretByteArr())
                .parseClaimsJws(token)
                .getBody();
    }

    /**
     * 解析token是否正确
     * @param token
     * @throws JwtException
     */
    public void parseToken(String token) throws JwtException {
        Jwts.parser().setSigningKey(getSecretByteArr()).parseClaimsJws(token).getBody();
    }

    /**
     * 验证token是否过期
     * @param token
     * @return
     */
    public boolean isExpred(String token) {
        try {
            final Date expireDate = getExpireDate(token);
            return expireDate.before(new Date());
        } catch (ExpiredJwtException e) {
            return true;
        }
    }

    /**
     * 生成token，用户名
     * @param username
     * @return
     */
    public String generateToken(String username, String userId, String randomKey) {
        Map<String, Object> claims = new HashMap<>(1);
        claims.put(jwtConfig.getMd5Key(), randomKey);
        return generateToken(claims, username, userId);
    }

    /**
     * 生成token
     * @param claims
     * @param username 用户名
     * @param userId 用户id
     * @return
     */
    public String generateToken(Map<String, Object> claims, String username, String userId) {
        final Date currDate = new Date();
        final Date expireDate = new Date(currDate.getTime() + jwtConfig.getExpiration());
        return Jwts.builder()
                .setClaims(claims) // 自定义属性
                .setAudience(userId) // 接受者
                .setSubject(username) // 主题
                .setIssuedAt(currDate) // 签发时间
                .setExpiration(expireDate) // 过期时间
                .signWith(SignatureAlgorithm.HS256, getSecretByteArr()) // 签名算法以及密匙
                .compact();
    }

    /**
     * 密钥base64数组
     * @return
     */
    private byte[] getSecretByteArr() {
        return Base64.decodeBase64(jwtConfig.getSecret());
    }
}
```



#### 增加拦截器 TokenInterceptor.java

```java
public class TokenInterceptor extends HandlerInterceptorAdapter {

    @Autowired
    private JwtUtil jwtUtils;

    @Autowired
    private JedisClusterClient jedisClusterClient;

    /**
     * 拦截
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 静态资源请求拦截
        if (handler instanceof ResourceHttpRequestHandler) {
            return true;
        }

        // 有RestIgnoreAnon注解的方法不拦
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            if (handlerMethod.hasMethodAnnotation(RestIgnoreAnon.class)) {
                return true;
            }
        }

        // 若是忽略的，则直接通过
        String requestPath = request.getServletPath();
        Iterator<String> it = RestApiConstant.IGNORE_SET.iterator();
        while (it.hasNext()) {
            if(requestPath.indexOf(it.next()) == 0) {
                return true;
            }
        }

        return checkToken(request, response);
    }

    /**
     * token校验
     * @param request
     * @param response
     * @return
     */
    private boolean checkToken(HttpServletRequest request, HttpServletResponse response) {
        // 校验请求是否包含验证信息
        String token = getToken(request);
        String id = getId(request)==null?"0":getId(request);

        // token 为空
        if (StringUtils.isBlank(token)) {
            WebUtils.write(response, JSONUtils.beanToJson(ResData.error(ResCode.C().TOKEN_NOT_FOUNT, ResMsg.TOKEN_NOT_FOUNT)));
            return false;
        }

        try {
            // token 过期
            boolean flag = jwtUtils.isExpred(token);
            if (flag) {
                WebUtils.write(response, JSONUtils.beanToJson(ResData.error(ResCode.C().TOKEN_EXPIRED, ResMsg.TOKEN_EXPIRED)));
                return false;
            }
        } catch (JwtException e) {
            log.info("token解析异常：{}", token);
            WebUtils.write(response, JSONUtils.beanToJson(ResData.error(ResCode.C().TOKEN_INVALID, ResMsg.TOKEN_INVALID)));
            return false;
        }

        // token校验
        String hget = jedisClusterClient.hget(UserTokenVO.GET_BY_ID, id);
        if (hget == null || StringUtils.isEmpty(hget)) {
            WebUtils.write(response, JSONUtils.beanToJson(ResData.error(ResCode.C().TOKEN_NOT_FOUNT, ResMsg.TOKEN_NOT_FOUNT)));
            return false;
        }

        UserTokenVO userTokenVO = JSONUtils.jsonToBean(hget, UserTokenVO.class);
        if (!token.equals(userTokenVO.getToken())) {
            WebUtils.write(response, JSONUtils.beanToJson(ResData.error(ResCode.C().TOKEN_INVALID, ResMsg.TOKEN_INVALID)));
            return false;
        }

//        // 用户校验，暂时不管
//        SysRegisterEntity sysRegister = registerService.getUserByIdForToken(sysUserTokenEntity.getUserId());
//        if (sysRegister.getApproveFlag() != 1) {
//            WebUtils.write(response, JSONUtils.beanToJson(RestApiConstant.TokenErrorEnum.USER_DISABLE.getResp()));
//            return false;
//        }

        return true;
    }

    /**
     * 获取token
     * @param request
     * @return
     */
    private String getToken(HttpServletRequest request) {
        // 请求头token
        String token = request.getHeader(RestApiConstant.AUTH_TOKEN);

        if (StringUtils.isBlank(token)) {
            // 请求参数token
            return request.getParameter(RestApiConstant.AUTH_TOKEN);
        }
        return token;
    }
    private String getId(HttpServletRequest request ) {
        String id = request.getHeader("IdentityId");
        if (StringUtils.isBlank(id)) {
            // 请求参数Id
            return request.getParameter("IdentityId");
        }
        return id;
    }
}
```



#### springmvc.xml 配置扫描和拦截器

扫描包时记得将 config 和 utils 都扫描进去

```xml
<mvc:interceptors>
    <mvc:interceptor>
        <!-- 匹配的是url路径， 如果不配置或/**,将拦截所有的Controller -->
        <mvc:mapping path="/**" />
<!--            <mvc:exclude-mapping path="/user/register" />-->
<!--            <mvc:exclude-mapping path="/user/login" />-->
        <bean class="com.upload.user.interceptor.TokenInterceptor"></bean>
    </mvc:interceptor>
</mvc:interceptors>
```



#### 在登录后生成token，并返回给前端

```java
@RequestMapping("/login")
@ApiOperation(value = "用户登录", httpMethod = "POST", notes = "用户输入账号密码登录平台", produces = "application/json")
@ApiOperationSupport(order = 2, author = "tom",
        includeParameters = {"user.account","user.password"}
)
@RestIgnoreAnon
public ResData<LoginVo> doLogin(@RequestBody User u) {
    User user= userService.selectByAccount(u.getAccount());
    // 若用户为空
    if(user == null) {
        return ResData.error(ResCode.C().ERROR, ResMsg.USER_ACCOUNT_NOTEXIST);
    }

    // 判断密码是否正确
    if (u.getPassword().equals(user.getPassword())) {
        // 生成 token
        String randomKey = TokenUtils.generateValue();
        String token = jwtUtil.generateToken(u.getAccount(),
                String.valueOf(user.getId()), randomKey);

        // 存储并返回
        LoginVo loginVo = new LoginVo(user.getId(), token, user.getUsername(), user.getAvatar(), user.getUserId());

        // 存储到 redis 集群中
        UserTokenVO userTokenVO = new UserTokenVO();
        userTokenVO.setId(String.valueOf(user.getId()));
        userTokenVO.setAccount(user.getAccount());
        userTokenVO.setCreated(new Date());
        userTokenVO.setUpdate(new Date());
        userTokenVO.setToken(token);
        jedisClusterClient.hset(UserTokenVO.GET_BY_ID, String.valueOf(user.getId()), JSONUtils.beanToJson(userTokenVO));

        return new ResData(ResCode.C().OK, ResMsg.USER_LOGIN_SUC, loginVo);
    }   else {
        return ResData.error(ResCode.C().ERROR, ResMsg.USER_PWD_ERROR);
    }
}
```



#### 配置自定义注解

增加上这个注解的请求不需要 token 验证

```java
/**
 * rest接口不需要授权注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RestIgnoreAnon {
}
```



#### 相关类

###### WebUtils.java

```java
package com.upload.common.utils;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.util.StringUtils;
import org.springframework.web.context.request.RequestContextHolder;
import org.springframework.web.context.request.ServletRequestAttributes;

import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * web工具类
 */
public class WebUtils {

    private static final Logger LOGGER = LoggerFactory.getLogger(WebUtils.class);

    /**
     * 是否为ajax请求
     *
     * @param request
     * @return
     */
    public static boolean isAjax(HttpServletRequest request) {
        String header = "x-requested-with", httpRequest = "XMLHttpRequest";
        //如果是ajax请求响应头会有，x-requested-with
        if (request.getHeader(header) != null
                && request.getHeader(header)
                .equalsIgnoreCase(httpRequest)) {
            return true;
        }
        return false;
    }

    /**
     * 页面输出
     *
     * @param response
     * @param o
     */
    public static void write(HttpServletResponse response, Object o) {
        try {
            response.setContentType("text/html;charset=utf-8");
            PrintWriter out = response.getWriter();
            out.println(o.toString());
            out.flush();
            out.close();
        } catch (IOException e) {
            LOGGER.error(e.getMessage(), e);
        }
    }

    /**
     * 获取httpServletRequest
     *
     * @return
     */
    public static HttpServletRequest getRequest() {
        HttpServletRequest request = ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getRequest();
//        return new XssHttpServletRequestWrapper(request);
        return request;
    }

    /**
     * 获取httpServletResponse
     *
     * @return
     */
    public static HttpServletResponse getResponse() {
        return ((ServletRequestAttributes) RequestContextHolder.getRequestAttributes()).getResponse();
    }

    /**
     * 获取用户真实IP地址，不使用request.getRemoteAddr()的原因是有可能用户使用了代理软件方式避免真实IP地址,
     * 可是，如果通过了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP值
     *
     * @return ip
     */
    private static String getIpAddrtest(HttpServletRequest request) {
        String ip = request.getHeader("x-forwarded-for");
        if (ip != null && ip.length() != 0 && !"unknown".equalsIgnoreCase(ip)) {
            // 多次反向代理后会有多个ip值，第一个ip才是真实ip
            if (ip.contains(",")) {
                ip = ip.split(",")[0];
            }
        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("Proxy-Client-IP");

        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("WL-Proxy-Client-IP");

        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_CLIENT_IP");

        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("HTTP_X_FORWARDED_FOR");

        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeader("X-Real-IP");

        }
        if (ip == null || ip.length() == 0 || "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddr();

        }
        return ip;
    }

    /**
     * 获取IP地址
     * <p>
     * 使用Nginx等反向代理软件， 则不能通过request.getRemoteAddr()获取IP地址
     * 如果使用了多级反向代理的话，X-Forwarded-For的值并不止一个，而是一串IP地址，X-Forwarded-For中第一个非unknown的有效IP字符串，则为真实IP地址
     */
    public static String getIpAddr(HttpServletRequest request) {
        String ip = null, unknown = "unknown", seperator = ",";
        int maxLength = 15;
        try {
            ip = request.getHeader("x-forwarded-for");
            if (StringUtils.isEmpty(ip) || unknown.equalsIgnoreCase(ip)) {
                ip = request.getHeader("Proxy-Client-IP");
            }
            if (StringUtils.isEmpty(ip) || ip.length() == 0 || unknown.equalsIgnoreCase(ip)) {
                ip = request.getHeader("WL-Proxy-Client-IP");
            }
            if (StringUtils.isEmpty(ip) || unknown.equalsIgnoreCase(ip)) {
                ip = request.getHeader("HTTP_CLIENT_IP");
            }
            if (StringUtils.isEmpty(ip) || unknown.equalsIgnoreCase(ip)) {
                ip = request.getHeader("HTTP_X_FORWARDED_FOR");
            }
            if (StringUtils.isEmpty(ip) || unknown.equalsIgnoreCase(ip)) {
                ip = request.getRemoteAddr();
            }
        } catch (Exception e) {
            LOGGER.error("WebUtils.getIpAddr ERROR ", e);
        }

        // 使用代理，则获取第一个IP地址
        if (StringUtils.isEmpty(ip) && ip.length() > maxLength) {
            int idx = ip.indexOf(seperator);
            if (idx > 0) {
                ip = ip.substring(0, idx);
            }
        }

        return ip;
    }

    /**
     * 获取ip地址
     *
     * @return
     */
    public static String getIpAddr() {
        HttpServletRequest request = WebUtils.getRequest();
        return getIpAddr(request);
    }
}
```



###### TokenUtils.java

```java
package com.upload.common.utils;

import java.security.MessageDigest;
import java.util.Date;
import java.util.UUID;

/**
 * token工具类
 */
public class TokenUtils {

    public static String generateValue() {
        return generateValue(UUID.randomUUID().toString());
    }

    private static final char[] hexCode = "0123456789abcdef".toCharArray();

    public static String toHexString(byte[] data) {
        if (data == null) {
            return null;
        }
        StringBuilder r = new StringBuilder(data.length * 2);
        for (byte b : data) {
            r.append(hexCode[(b >> 4) & 0xF]);
            r.append(hexCode[(b & 0xF)]);
        }
        return r.toString();
    }

    public static String generateValue(String param) {
        try {
            MessageDigest algorithm = MessageDigest.getInstance("MD5");
            algorithm.reset();
            algorithm.update(param.getBytes());
            byte[] messageDigest = algorithm.digest();
            return toHexString(messageDigest);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return "";
    }

    /**
     * token是否过期
     *
     * @param tokenExpireTime
     * @return
     */
    public static boolean isExpired(Date tokenExpireTime) {
        return tokenExpireTime.getTime() < System.currentTimeMillis();
    }
}
```



###### JsonUtils.java

```java
package com.upload.common.utils;

import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;

/**
 * json工具类(jackjson)
 */
public class JSONUtils {

	private final static ObjectMapper objectMapper = new ObjectMapper();

    private JSONUtils() {

    }

    public static ObjectMapper getInstance() {
        return objectMapper;
    }

    /**
     * object转化json
     * @param obj
     * @return
     * @throws Exception
     */
    public static String beanToJson(Object obj) {
        try {
			return objectMapper.writeValueAsString(obj);
		} catch (JsonProcessingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        return null;
    }

    /**
     * json转对象
     * @param jsonStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> T jsonToBean(String jsonStr, Class<T> clazz) {
        try {
			return objectMapper.readValue(jsonStr, clazz);
		} catch (JsonParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (JsonMappingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        return null;
    }

    /**
     * json转map
     * @param jsonStr
     * @return
     * @throws Exception
     */
    @SuppressWarnings("unchecked")
	public static <T> Map<String, Object> jsonToMap(String jsonStr)
            throws Exception {
        return objectMapper.readValue(jsonStr, Map.class);
    }

    /**
     * json转map，指定类型
     * @param jsonStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> Map<String, T> jsonToMap(String jsonStr, Class<T> clazz)
            throws Exception {
        Map<String, Map<String, Object>> map = (Map<String, Map<String, Object>>) objectMapper.readValue(jsonStr,
                new TypeReference<Map<String, T>>() {
                });
        Map<String, T> result = new HashMap<String, T>();
        for (Entry<String, Map<String, Object>> entry : map.entrySet()) {
            result.put(entry.getKey(), mapToBean(entry.getValue(), clazz));
        }
        return result;
    }

    /**
     * json数组转list，指定类型
     * @param jsonArrayStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> List<T> jsonToList(String jsonArrayStr, Class<T> clazz)
            throws Exception {
        List<Map<String, Object>> list = (List<Map<String, Object>>) objectMapper.readValue(jsonArrayStr,
                new TypeReference<List<T>>() {
                });
        List<T> result = new ArrayList<T>();
        for (Map<String, Object> map : list) {
            result.add(mapToBean(map, clazz));        }
        return result;
    }

    /**
     * map转化对象
     */
    @SuppressWarnings("rawtypes")
	public static <T> T mapToBean(Map map, Class<T> clazz) {
        return objectMapper.convertValue(map, clazz);
    }
}
```





RestApiConstant.java

```java
package com.upload.common.constant;

import java.util.HashSet;
import java.util.Set;

public class RestApiConstant {

    /** 授权标识 **/
    public static final String AUTH_TOKEN = "token";

    /** token有效期校验请求 **/
    public static final String AUTH_REQUIRE = "/rest";

    /** 后台-请求验证地址 **/
    public static final String AUTH_REQUEST = "/rest/auth";


    public static final String AUTH_CHECK = "/rest/authStatus";

    public static final Set<String> IGNORE_SET = new HashSet<String>() {
        {
            /** 后台-请求验证地址 **/
            add("/rest/auth");
            /** 后台-token有效期校验请求 **/
            add("/rest/authStatus");
            /** swagger文档 **/
            add("/swagger");
            add("/v2");
        }
    };
}
```



###### ResCode.java

```java
package com.upload.common.pojo;

import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

@ApiModel(description = "自定义响应状态码")
public class ResCode {

    // 请求成功
    @ApiModelProperty(value = "(0) 请求成功")
    public int OK = 0;

    // 失败
    @ApiModelProperty(value = "(-1) 请求失败")
    public int ERROR = -1;

    // 数据为空
    @ApiModelProperty(value = "(-2000) 数据为空")
    public int IS_NULL = -2000;

    @ApiModelProperty(value = "(-1000) 获取的token为空")
    public int TOKEN_NOT_FOUNT = -1000;

    @ApiModelProperty(value = "(-1001) 无效的token")
    public int TOKEN_INVALID = -1001;

    @ApiModelProperty(value = "(-1002) 过期的token")
    public int TOKEN_EXPIRED = -1002;

    public static ResCode C() {
        return new ResCode();
    }
}
```



###### UserTokenVO.java

```java
@ApiModel(description = "存储在redis中的用户模型")
public class UserTokenVO {

    // 根据id获取token
    public static final String GET_BY_ID = "GET_TOKEN_BY_ID";
    // 根据token获取
    public static final String GET_BY_TOKEN= "GET_ID_BY_TOKEN";

    private String id;

    @ApiModelProperty("用户账号")
    private String account;

    @ApiModelProperty("用户token")
    private String token;

    @ApiModelProperty("token创建时间")
    private Date created;

    @ApiModelProperty("token更新时间")
    private Date update;

    ... 记得写 get set 方法
}

```



## 八、Shiro

### 8.1 基本概念

#### Shiro

Shiro 是一个轻量型授权框架，能够提供对用户的认证和授权管理，同类型的授权框架还有 Spring Security 。



#### **Shiro与 Spring Security  的对比**

Shiro 比 Spring Security  更容易集成， Spring Security 需要进行复杂的配置

Spring Security 有更好的社区支持

Spring Security 对 spirng 的结合性更高

Shiro 不与任何框架和容器绑定，可以独立运行



#### 认证和授权

**身份认证**

身份认证即判断一个用户是否为合法用户，是否能够登陆系统



**授权**

授权即访问控制，控制谁能够访问哪些资源。主体身份认证后需要分配权限才可以访问系统资源，无法访问没有被授权的资源



### 8.2 模块分析

#### 8.2.1 整体架构图

![image-20201230103755562](E:\tmp\笔记\日常纪要.assets\image-20201230103755562.png)



#### 8.2.2 模块介绍

| 名称            | 描述                                                         |
| :-------------- | ------------------------------------------------------------ |
| Subject         | **主体**，即指访问 Shiro 的外部应用，或特指一个用户。Subject 在 Shiro 中是一个接口，接口中定义了很多认证授权相关的方法，外部程序通过 subject 提供的方法进行认证和授权。而实际 Subject 是通过 Security Manager 安全管理器实现功能的 |
| SecurityManager | **安全管理器**，对全部的 Subject 进行安全管理，可以完成对 Subject 的认证、授权等。而实际上 SecurityManager 是在 Authenticator 进行认证，通过 Authorizer 进行授权，通过 SessionManager 进行会话管理的 |
| Authenticator   | **认证器**，用于对用户身份进行认证，Shiro 提供了 ModularRealmAuthenticator 实现类，也支持自定义认证器 |
| Authorizer      | **授权器**，用户在认证器通过后，在访问功能时需要通过授权器判断用户是否有此功能的操作权限 |
| Realm           | **领域**，SecurityManager 进行安全认证时需要通过 Realm 获取用户权限数据，如通过 Realm 从数据库或缓存中获取用户身份信息 |
| SessionManager  | **会话管理器**，Shiro 框架定义了自己的一套会话管理，不依赖 web 容器的 session，故可以兼容各种主体对象，同时也支持将分布式应用的会话集中在一点管理，以此可以实现单点登录 |
| SessionDAO      | **会话DAO**，对 session 会话的一套接口，如将 session 存储到数据库等 |
| CacheManager    | **缓存管理**，将用户权限数据存储在缓存中，避免每次都要查询数据库 |
| Cryptography    | **密码管理**，Shiro 提供了一套加解密的组件，提供了常用的散列、加解密功能 |



### 8.3 认证

#### 8.3.1 概念

认证即判断一个用户是否为合法用户的过程，如判断传入的账号和密码，与存储中的账号和密码是否匹配



#### 8.3.2 Shiro 中认证的关键对象

- **Subject：主体**

访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体； 

- **Principal：身份信息**

是主体（subject）进行身份认证的标识，标识必须具有`唯一性`，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。

- **credential：凭证信息**

是只有主体自己知道的安全信息，如密码、证书等。



#### 8.3.3 认证流程

![image-20200521204452288](E:\tmp\笔记\日常纪要.assets\image-20200521204452288.png)





#### 8.3.4 示例代码

##### 自定义Realm, 并认证

```
/**
 * 自定义realm
 */
public class CustomerRealm extends AuthorizingRealm {
    //认证方法
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {
        return null;
    }

    //授权方法
    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {
        String principal = (String) token.getPrincipal();
        if("xiaochen".equals(principal)){
            return new SimpleAuthenticationInfo(principal,"123",this.getName());
        }
        return null;
    }
}
```

```
/**
 * 使用自定义realm认证
 */
public class TestAuthenticatorCusttomerRealm {
    public static void main(String[] args) {
        //创建securityManager
        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();
        //IniRealm realm = new IniRealm("classpath:shiro.ini");
        //设置为自定义realm获取认证数据
        defaultSecurityManager.setRealm(new CustomerRealm());
        //将安装工具类中设置默认安全管理器
        SecurityUtils.setSecurityManager(defaultSecurityManager);
        //获取主体对象
        Subject subject = SecurityUtils.getSubject();
        //创建token令牌
        UsernamePasswordToken token = new UsernamePasswordToken("xiaochen", "123");
        try {
            subject.login(token);//用户登录
            System.out.println("登录成功~~");
        } catch (UnknownAccountException e) {
            e.printStackTrace();
            System.out.println("用户名错误!!");
        }catch (IncorrectCredentialsException e){
            e.printStackTrace();
            System.out.println("密码错误!!!");
        }

    }
}
```



##### 使用 MD5 + salt + hash散列



通过设定 HashedCredentialsMatcher 的参数实现 md5 算法的使用，以及散列次数。同时可以在 CustomMd5Realm 中设置md5的盐提高解密难

- **设定md5对口令加密：** credentialsMatcher.setHashAlgorithmName("md5");

- **设定md5加密的盐**：在自定义 realm 中： ByteSource.Util.bytes([盐值])

  ​          `return new SimpleAuthenticationInfo(principal, "3e6ad4399c09567104ace21f2119d813", ByteSource.Util.bytes("xx-00"), this.getName());`

- **设定哈希散列：**credentialsMatcher.setHashIterations(1024);

```java
import org.apache.shiro.authc.AuthenticationException;
import org.apache.shiro.authc.AuthenticationInfo;
import org.apache.shiro.authc.AuthenticationToken;
import org.apache.shiro.authc.SimpleAuthenticationInfo;
import org.apache.shiro.authz.AuthorizationInfo;
import org.apache.shiro.realm.AuthorizingRealm;
import org.apache.shiro.subject.PrincipalCollection;

/**
 * 使用自定义 realm 加入md5
 */
public class CustomMd5Realm extends AuthorizingRealm {
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        return null;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        // 获取验证人身份
        String principal = (String) authenticationToken.getPrincipal();

        if ("tom".equals(principal)) {
            return new SimpleAuthenticationInfo(principal, "202cb962ac59075b964b07152d234b70", this.getName());
        }
        
//        // ByteSource.Util.bytes md5 加上随机盐
//        if ("tom".equals(principal)) {
//            return new SimpleAuthenticationInfo(principal,
//                    "3e6ad4399c09567104ace21f2119d813",
//                    ByteSource.Util.bytes("xx-00"),
//                    this.getName());
//        }

        return null;
    }
}
```

```java
public class TestMD5Authenticator {

    public static void main(String[] args) {
        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();

        CustomMd5AndSaltRealm realm = new CustomMd5AndSaltRealm();
        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();
        // 使用 MD5 算法
        credentialsMatcher.setHashAlgorithmName("md5");
        // 设定散列次数
        credentialsMatcher.setHashIterations(1024);

        realm.setCredentialsMatcher(credentialsMatcher);
        defaultSecurityManager.setRealm(realm);

        SecurityUtils.setSecurityManager(defaultSecurityManager);
        Subject subject = SecurityUtils.getSubject();

        UsernamePasswordToken token = new UsernamePasswordToken("tom","123");
        try {
            System.out.println("认证状态 = " + subject.isAuthenticated());
            subject.login(token);
            System.out.println("认证状态22 = " + subject.isAuthenticated());
        } catch (UnknownAccountException e) {
            System.out.println("认证失败： 用户不存在");
        } catch (IncorrectCredentialsException e) {
            System.out.println("认证失败： 令牌错误");
        }
    }
}
```



#### 8.3.5 认证失败异常列举

- UnknownAccountException（账号不存在）
- IncorrectCredentialsException（令牌验证错误）
- DisabledAccountException（帐号被禁用）
- LockedAccountException（帐号被锁定）
- ExcessiveAttemptsException（登录失败次数过多）
- ExpiredCredentialsException（凭证过期）等



### 8.4 授权

#### 8.4.1 概念

授权即访问控制，决定谁可以访问那些资源。在主体通过身份验证后，需要分配权限才可以访问系统的资源，无法访问没有授予权限的资源



#### 8.4.2 Shiro 中授权的关键对象

- **Subject：主体**

访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体； 

- **Resource：资源**

如系统菜单、页面、按钮、类方法、系统商品信息等。资源包括`资源类型`和`资源实例`，比如`商品信息为资源类型`，类型为t01的商品为`资源实例`，编号为001的商品信息也属于资源实例

- **PerMission：权限/许可**

规定了主体对资源的操作许可，权限离开资源没有意义，如用户查询权限、用户添加权限、某个类方法的调用权限、编号为001用户的修改权限等，通过权限可知主体对哪些资源都有哪些操作许可。



#### 8.4.3 授权流程

![image-20200521230705964](E:\tmp\笔记\日常纪要.assets\image-20200521230705964.png)



#### 8.4.4 授权方式

- **基于角色的访问控制**

  - RBAC基于角色的访问控制（Role-Based Access Control）是以角色为中心进行访问控制

    ```java
    if(subject.hasRole("admin")){
       //操作什么资源
    }
    ```

- **基于资源的访问控制**

  - RBAC基于资源的访问控制（Resource-Based Access Control）是以资源为中心进行访问控制

    ```java
    if(subject.isPermission("user:find:*")){ //资源类型
      //对所有用户具有查询权限
    }
    if(subject.isPermission("user:update:01")){ //资源实例
      //对01用户进行修改
    }
    if(subject.isPermission("user:update:*")){  //资源类型
      //对所有用户进行修改
    }
    ```



#### 8.4.5 权限字符串

​		`权限字符串的规则是：资源标识符：操作：资源实例标识符`，意思是对哪个资源的哪个实例具有什么操作，“:”是资源/操作/实例的分割符，权限字符串也可以使用*通配符。

例子：

- 用户创建权限：user:create，或user:create:*
- 用户修改实例001的权限：user:update:001
- 用户实例001的所有权限：user:*：001



#### 8.4.6 实现方式

- **编程式**

  ```java
  Subject subject = SecurityUtils.getSubject();
  if(subject.hasRole(“admin”)) {
  	//有权限
  } else {
  	//无权限
  }
  ```

- **注解式**

  ```java
  @RequiresRoles("admin")
  public void hello() {
  	//有权限
  }
  ```

- **标签式**

  ```jsp
  JSP/GSP 标签：在JSP/GSP 页面通过相应的标签完成：
  <shiro:hasRole name="admin">
  	<!— 有权限—>
  </shiro:hasRole>
  注意: Thymeleaf 中使用shiro需要额外集成!
  ```



### 8.5 会话管理




### 8.5 SpringBoot 整合Shiro

https://blog.csdn.net/weixin_43753812/article/details/102967686

#### 8.5.1 项目搭建

###### 引入依赖

```xml
<!-- https://mvnrepository.com/artifact/org.apache.shiro/shiro-spring-boot-starter -->
<dependency>
    <groupId>org.apache.shiro</groupId>
    <artifactId>shiro-spring-boot-starter</artifactId>
    <version>1.5.3</version>
</dependency>

<!--mybatis相关依赖-->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.1.2</version>
</dependency>

<!--mysql-->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.11</version>
</dependency>

<!--druid-->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.19</version>
</dependency>

...

<build>
    <resources>
        <resource>
            <directory>src/main/java</directory>
            <includes>
                <include>**/*.properties</include>
                <include>**/*.xml</include>
            </includes>
            <filtering>false</filtering>
        </resource>
    </resources>
</build>
```



###### 增加 Shiro 配置类 ShiroConfig.java

```java
package com.tom.shirospringboot.config;

import com.tom.shirospringboot.shiro.UserRealm;
import org.apache.shiro.authc.credential.HashedCredentialsMatcher;
import org.apache.shiro.realm.Realm;
import org.apache.shiro.spring.web.ShiroFilterFactoryBean;
import org.apache.shiro.web.mgt.DefaultWebSecurityManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.HashMap;
import java.util.Map;

/**
 * 整合shiro框架相关的配置类
 */
@Configuration
public class ShiroConfig {

    // 1. 创建 ShiroFilter
    @Bean
    public ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager) {
        ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();

        // 给 filter 设置安全管理器
        shiroFilterFactoryBean.setSecurityManager(defaultWebSecurityManager);

        // 配置系统的受限资源
        Map<String, String> map = new HashMap<String, String>();
        map.put("/user/login", "anon"); // 请求这个资源不需要认证和授权
        map.put("/user/register", "anon");
        map.put("/register.jsp", "anon");
        map.put("/**", "authc"); // 请求这个资源需要认证和授权
        shiroFilterFactoryBean.setFilterChainDefinitionMap(map);

        // 配置系统的公共资源

        // 默认重定向路径，默认找 login.jsp
        shiroFilterFactoryBean.setLoginUrl("/login.jsp");
        return shiroFilterFactoryBean;
    }

    // 创建安全管理器
    @Bean
    public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm) {
        DefaultWebSecurityManager defaultWebSecurityManager = new DefaultWebSecurityManager();

        //给安全管理器设置 realm
        defaultWebSecurityManager.setRealm(realm);

        return defaultWebSecurityManager;
    }

    // 自定义 Realm
    @Bean
    public Realm getRealm() {
        UserRealm userRealm = new UserRealm();
        // 修改凭证校验匹配器
        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();
        credentialsMatcher.setHashAlgorithmName("md5");
        credentialsMatcher.setHashIterations(1024);
        userRealm.setCredentialsMatcher(credentialsMatcher);
        return userRealm;
    }
}
```



###### 自定义 Realm

```Java
public class UserRealm extends AuthorizingRealm {
    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        String primaryPrincipal = (String) principalCollection.getPrimaryPrincipal();

        // 此处改为从数据库获取，并导入对应的身份信息和操作授权
        if ("lincya".equals(primaryPrincipal)) {
            SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
            simpleAuthorizationInfo.addRole("admin");
            simpleAuthorizationInfo.addStringPermission("user:*:*");
            return simpleAuthorizationInfo;
        }
        return null;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        System.out.println("==============================");
        String principal = (String) authenticationToken.getPrincipal();
        SimpleAuthenticationInfo simpleAuthenticationInfo = new SimpleAuthenticationInfo(principal,"123",this.getName());

        UserService userService = (UserService) ApplicationContextUtils.getBean("userService");
        System.out.println(userService);
        User user = userService.findByUserName(principal);
        if (!ObjectUtils.isEmpty(user)) {
            return new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), ByteSource.Util.bytes(user.getSalt()), this.getName());
        }
        return null;
    }
}
```



###### 加盐工具类

```Java
public class SaltUtils {
    /**
     * 生成salt的静态方法
     * @param n
     * @return
     */
    public static String getSalt(int n){
        char[] chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890!@#$%^&*()".toCharArray();
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < n; i++) {
            char aChar = chars[new Random().nextInt(chars.length)];
            sb.append(aChar);
        }
        return sb.toString();
    }
}
```



###### 获取 Bean 对象的工具

```java
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class ApplicationContextUtils implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.context = applicationContext;
    }


    //根据bean名字获取工厂中指定bean 对象
    public static Object getBean(String beanName){
        return context.getBean(beanName);
    }
}
```



###### 使用

```java
@Controller
@RequestMapping("/user")
public class UserController {
    @Autowired
    private UserService userService;

    /**
     * 用户注册
     */
    @RequestMapping("/register")
    public String register(User user) {
        try {
            userService.register(user);
            return "redirect:/login.jsp";
        }catch (Exception e){
            e.printStackTrace();
            return "redirect:/register.jsp";
        }
    }

    @RequestMapping("/login")
    public String login(String username, String password) {
        Subject subject = SecurityUtils.getSubject();
        try {
            subject.login(new UsernamePasswordToken(username, password));
            return "redirect:/index.jsp";
        } catch (UnknownAccountException e) {
            System.out.println("用户名错误！");
        } catch (IncorrectCredentialsException e) {
            System.out.println("密码错误！");
        }

        return "redirect:/login.jsp";
    }

    @RequestMapping("/logout")
    public String logout() {
        Subject subject = SecurityUtils.getSubject();
        subject.logout();
        return "redirect:/login.jsp";
    }
}
```



```java
import com.tom.shirospringboot.entity.User;
import com.tom.shirospringboot.mapper.UserDao;
import com.tom.shirospringboot.service.UserService;
import com.tom.shirospringboot.utils.SaltUtils;
import org.apache.shiro.crypto.hash.Md5Hash;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

@Service("userService")
@Transactional
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    @Override
    public void register(User user) {
        //处理业务调用dao
        //1.生成随机盐
        String salt = SaltUtils.getSalt(8);
        //2.将随机盐保存到数据
        user.setSalt(salt);
        //3.明文密码进行md5 + salt + hash散列
        Md5Hash md5Hash = new Md5Hash(user.getPassword(),salt,1024);
        user.setPassword(md5Hash.toHex());
        userDao.save(user);
    }

    @Override
    public User findByUserName(String username) {
        return userDao.findByUserName(username);
    }
}
```

login.jsp

```jsp
<%@page contentType="text/html; UTF-8" pageEncoding="utf-8" isELIgnored="false" %>
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>demo</title>
</head>
<body>
    <h1>用户登录</h1>

    <form action="${pageContext.request.contextPath}/user/login" method="post">
        用户名：<input type="text" name="username"><br/>
        密码：<input type="text" name="password"><br/>
        <input type="submit" value="登录">
    </form>
</body>
</html>
```

register.jsp

```jsp
<%@page contentType="text/html; UTF-8" pageEncoding="utf-8" isELIgnored="false" %>
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>demo</title>
</head>
<body>
    <h1>注册</h1>

    <form action="${pageContext.request.contextPath}/user/register" method="post">
        用户名：<input type="text" name="username"><br/>
        密码：<input type="text" name="password"><br/>
        <input type="submit" value="提交">
    </form>
</body>
</html>
```

index.jsp

```jsp
<%@page contentType="text/html; UTF-8" pageEncoding="utf-8" isELIgnored="false" %>
<%@taglib prefix="shiro" uri="http://shiro.apache.org/tags" %>
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>demo</title>
</head>
<body>
    <h1>系统主页v1.0</h1>
    <a href="${pageContext.request.contextPath}/user/logout">退出</a>
    <shiro:hasAnyRoles name="user,admin">
        <li><a href="">用户管理</a>
            <ul>
                <shiro:hasPermission name="user:add:*">
                    <li><a href="${pageContext.request.contextPath}/order/save">添加</a></li>
                </shiro:hasPermission>
                <shiro:hasPermission name="user:delete:*">
                    <li><a href="">删除</a></li>
                </shiro:hasPermission>
                <shiro:hasPermission name="user:update:*">
                    <li><a href="">修改</a></li>
                </shiro:hasPermission>
                <shiro:hasPermission name="user:find:*">
                    <li><a href="">查询</a></li>
                </shiro:hasPermission>
            </ul>
        </li>
    </shiro:hasAnyRoles>
    <shiro:hasRole name="admin">
        <li><a href="">商品管理</a></li>
        <li><a href="">订单管理</a></li>
        <li><a href="">物流管理</a></li>
    </shiro:hasRole>
</body>
</html>
```



#### 8.5.2 常见过滤器

- 注意: **shiro提供和多个默认的过滤器，我们可以用这些过滤器来配置控制指定url的权限：**

| 配置缩写          | 对应的过滤器                   | 功能                                                         |
| ----------------- | ------------------------------ | ------------------------------------------------------------ |
| anon              | AnonymousFilter                | 指定url可以匿名访问                                          |
| authc             | FormAuthenticationFilter       | 指定url需要form表单登录，默认会从请求中获取`username`、`password`,`rememberMe`等参数并尝试登录，如果登录不了就会跳转到loginUrl配置的路径。我们也可以用这个过滤器做默认的登录逻辑，但是一般都是我们自己在控制器写登录逻辑的，自己写的话出错返回的信息都可以定制嘛。 |
| authcBasic        | BasicHttpAuthenticationFilter  | 指定url需要basic登录                                         |
| logout            | LogoutFilter                   | 登出过滤器，配置指定url就可以实现退出功能，非常方便          |
| noSessionCreation | NoSessionCreationFilter        | 禁止创建会话                                                 |
| perms             | PermissionsAuthorizationFilter | 需要指定权限才能访问                                         |
| port              | PortFilter                     | 需要指定端口才能访问                                         |
| rest              | HttpMethodPermissionFilter     | 将http请求方法转化成相应的动词来构造一个权限字符串，这个感觉意义不大，有兴趣自己看源码的注释 |
| roles             | RolesAuthorizationFilter       | 需要指定角色才能访问                                         |
| ssl               | SslFilter                      | 需要https请求才能访问                                        |
| user              | UserFilter                     | 需要已登录或“记住我”的用户才能访问                           |



#### 8.5.3 数据持久化

在上面的基础上，应该将用户的角色信息和操作权限等，和用户联系起来，并存储到数据库中

![image-20200527204839080](file://F:/study/Java/doc/Shiro%20%E5%AE%9E%E6%88%98%E6%95%99%E7%A8%8B.assets/image-20200527204839080.png?lastModify=1609572261)

新建数据库表

```sql
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- 权限表，这个是简单的，复杂的权限表sql在下面
CREATE TABLE `t_perms` (
  `id` int(6) NOT NULL AUTO_INCREMENT,
  `name` varchar(80) DEFAULT NULL,
  `url` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 角色表
CREATE TABLE `t_role` (
  `id` int(6) NOT NULL AUTO_INCREMENT,
  `name` varchar(60) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 角色-权限表
DROP TABLE IF EXISTS `t_role_perms`;
CREATE TABLE `t_role_perms` (
  `id` int(6) NOT NULL,
  `roleid` int(6) DEFAULT NULL,
  `permsid` int(6) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- 用户表
CREATE TABLE `t_user` (
  `id` int(6) NOT NULL AUTO_INCREMENT,
  `username` varchar(40) DEFAULT NULL,
  `password` varchar(40) DEFAULT NULL,
  `salt` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- 用户-角色表
CREATE TABLE `t_user_role` (
  `id` int(6) NOT NULL,
  `userid` int(6) DEFAULT NULL,
  `roleid` int(6) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

SET FOREIGN_KEY_CHECKS = 1;
```



实际权限表可以拓展

```sql
create table menu
(
    menu_id      bigint auto_increment comment '菜单id'
        primary key,
    parent_id    bigint       null comment '父菜单ID，一级菜单为0',
    name         varchar(50)  null comment '菜单名称',
    url          varchar(200) null comment '菜单URL',
    perms        varchar(500) null comment '授权(多个用逗号分隔，如：user:list,user:create)',
    type         int          null comment '类型   0：目录   1：菜单   2：按钮',
    icon         varchar(50)  null comment '菜单图标',
    order_num    int          null comment '排序',
    gmt_create   datetime     null comment '创建时间',
    gmt_modified datetime     null comment '修改时间'
) comment '菜单管理' charset = utf8;
```





修改自定义类中的授权处理

```java
@Override
protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
    String primaryPrincipal = (String) principalCollection.getPrimaryPrincipal();

    UserService userService = (UserService) ApplicationContextUtils.getBean("userService");

    // 获取角色信息
    List<Role> roles = userService.findRoleByUserName(primaryPrincipal);
    SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
    if (!CollectionUtils.isEmpty(roles)) {
        roles.forEach(role -> {
            simpleAuthorizationInfo.addRole(role.getName());

            // 获取角色对应的权限信息
            List<Perms> perms = userService.findPermsByRoleId(role.getId());
            if (!CollectionUtils.isEmpty(perms)) {
                perms.forEach(perm -> {
                    simpleAuthorizationInfo.addStringPermission(perm.getName());
                });
            }
        });
    }
    return simpleAuthorizationInfo;
}
```





### 8.6 整合 redis 做缓存

由于默认的缓存感觉不好用，故自己使用 redis 存储实现缓存

#### 整合 Redis 

看上面 Springboot 整合 redis



#### 使用 Redis 存取数据

##### 修改授权方法

```java
public class UserRealm extends AuthorizingRealm {
    private String REDIS_AUTHOR = "SHIRO_AUTHORIZATION";

    @Override
    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) {
        String primaryPrincipal = (String) principalCollection.getPrimaryPrincipal();
        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();
        RedisTemplateUtils redisTemplateUtils = (RedisTemplateUtils) ApplicationContextUtils.getBean("RedisTemplateUtils");

        // 尝试直接从redis获取角色信息
        String authorStr = (String) redisTemplateUtils.hget(REDIS_AUTHOR, primaryPrincipal);
        if (authorStr != null) {
            ShiroUserVO shiroUserVO = JSONUtils.jsonToBean(authorStr, ShiroUserVO.class);
            if(!CollectionUtils.isEmpty(shiroUserVO.getRoles())) {
                shiroUserVO.getRoles().forEach(role -> {
                    simpleAuthorizationInfo.addRole(role.getName());
                });
            }

            if(!CollectionUtils.isEmpty(shiroUserVO.getPerms())) {
                shiroUserVO.getPerms().forEach(perm -> {
                    simpleAuthorizationInfo.addStringPermission(perm.getName());
                });
            }

            return simpleAuthorizationInfo;
        }

        // 若redis中没有数据，则从数据库查询，并存入redis
        ShiroUserVO newShiroUserVO = new ShiroUserVO();
        newShiroUserVO.setAccount(primaryPrincipal);
        UserService userService = (UserService) ApplicationContextUtils.getBean("userService");

        // 获取角色信息
        List<Role> roles = userService.findRoleByUserName(primaryPrincipal);
        if (!CollectionUtils.isEmpty(roles)) {
            newShiroUserVO.setRoles(roles);
            roles.forEach(role -> {
                simpleAuthorizationInfo.addRole(role.getName());

                // 获取角色对应的权限信息
                List<Perms> perms = userService.findPermsByRoleId(role.getId());
                if (!CollectionUtils.isEmpty(perms)) {
                    newShiroUserVO.setPerms(perms);
                    perms.forEach(perm -> {
                        simpleAuthorizationInfo.addStringPermission(perm.getName());
                    });
                }
            });
        }

        // 存入 redis 中
        String shiroStr = JSONUtils.beanToJson(newShiroUserVO);
        redisTemplateUtils.hset(REDIS_AUTHOR, primaryPrincipal, shiroStr);

        return simpleAuthorizationInfo;
    }

    @Override
    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException {
        String principal = (String) authenticationToken.getPrincipal();
        UserService userService = (UserService) ApplicationContextUtils.getBean("userService");
        User user = userService.findByUserName(principal);
        if (!ObjectUtils.isEmpty(user)) {
            return new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(), ByteSource.Util.bytes(user.getSalt()), this.getName());
        }
        return null;
    }
}
```



##### 工具类

```java
/**
 * json工具类(jackjson)
 */
public class JSONUtils {

	private final static ObjectMapper objectMapper = new ObjectMapper();

    private JSONUtils() {

    }

    public static ObjectMapper getInstance() {
        return objectMapper;
    }

    /**
     * object转化json
     * @param obj
     * @return
     * @throws Exception
     */
    public static String beanToJson(Object obj) {
        try {
			return objectMapper.writeValueAsString(obj);
		} catch (JsonProcessingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        return null;
    }

    /**
     * json转对象
     * @param jsonStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> T jsonToBean(String jsonStr, Class<T> clazz) {
        try {
			return objectMapper.readValue(jsonStr, clazz);
		} catch (JsonParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (JsonMappingException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        return null;
    }

    /**
     * json转map
     * @param jsonStr
     * @return
     * @throws Exception
     */
    @SuppressWarnings("unchecked")
	public static <T> Map<String, Object> jsonToMap(String jsonStr)
            throws Exception {
        return objectMapper.readValue(jsonStr, Map.class);
    }

    /**
     * json转map，指定类型
     * @param jsonStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> Map<String, T> jsonToMap(String jsonStr, Class<T> clazz)
            throws Exception {
        Map<String, Map<String, Object>> map = (Map<String, Map<String, Object>>) objectMapper.readValue(jsonStr,
                new TypeReference<Map<String, T>>() {
                });
        Map<String, T> result = new HashMap<String, T>();
        for (Entry<String, Map<String, Object>> entry : map.entrySet()) {
            result.put(entry.getKey(), mapToBean(entry.getValue(), clazz));
        }
        return result;
    }

    /**
     * json数组转list，指定类型
     * @param jsonArrayStr
     * @param clazz
     * @return
     * @throws Exception
     */
    public static <T> List<T> jsonToList(String jsonArrayStr, Class<T> clazz)
            throws Exception {
        List<Map<String, Object>> list = (List<Map<String, Object>>) objectMapper.readValue(jsonArrayStr,
                new TypeReference<List<T>>() {
                });
        List<T> result = new ArrayList<T>();
        for (Map<String, Object> map : list) {
            result.add(mapToBean(map, clazz));        }
        return result;
    }

    /**
     * map转化对象
     */
    @SuppressWarnings("rawtypes")
	public static <T> T mapToBean(Map map, Class<T> clazz) {
        return objectMapper.convertValue(map, clazz);
    }
	
}
```



##### VO 类

```java
@Data
public class ShiroUserVO {
    private String account;
    private List<Role> roles;
    private List<Perms> perms;
}
```





## 九、SpringBoot - 三方工具

### 9.1 Mybatis-plus

#### 9.1.1 整合

##### 引入依赖

```xml
<!-- mybatis plus 代码生成器 -->
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-boot-starter</artifactId>
    <version>3.2.0</version>
</dependency>
<dependency>
    <groupId>com.baomidou</groupId>
    <artifactId>mybatis-plus-generator</artifactId>
    <version>3.2.0</version>
</dependency>
<dependency>
    <groupId>org.freemarker</groupId>
    <artifactId>freemarker</artifactId>
    <version>2.3.28</version>
</dependency>
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.47</version>
</dependency>
<!-- MySql -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.11</version>
</dependency>
<!-- 连接池 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.0.9</version>
</dependency>
```



##### 修改配置文件

```properties
mybatis-plus:
  global-config:
    db-config:
      id-type: auto
      field-strategy: not_empty
        #驼峰下划线转换
      column-underline: true
        #逻辑删除配置
      logic-delete-value: 0
      logic-not-delete-value: 1
      db-type: mysql
    refresh: false
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: false
```



##### 增加逆向工程生成类

`需要修改的：DataSourceConfig、GlobalConfig 的相关配置`

由于设置了覆盖，故如果开启了生成 controller、service 的话，小心被覆盖！

```java
import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;
import com.baomidou.mybatisplus.core.toolkit.StringUtils;
import com.baomidou.mybatisplus.generator.AutoGenerator;
import com.baomidou.mybatisplus.generator.config.*;
import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;
import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;

import java.util.Scanner;

/**
 * 自动生成mybatisplus的相关代码
 */
public class GeneratorCodeConfig {

    public static String scanner(String tip) {
        Scanner scanner = new Scanner(System.in);
        StringBuilder help = new StringBuilder();
        help.append("请输入" + tip + "：");
        System.out.println(help.toString());
        if (scanner.hasNext()) {
            String ipt = scanner.next();
            if (StringUtils.isNotEmpty(ipt)) {
                return ipt;
            }
        }
        throw new MybatisPlusException("请输入正确的" + tip + "！");
    }

    public static void main(String[] args) {
        // 代码生成器
        AutoGenerator mpg = new AutoGenerator();

        // 全局配置
        GlobalConfig gc = new GlobalConfig();
        String projectPath = System.getProperty("user.dir");
        String projectName = "/upload-plat-user";
        gc.setOutputDir(projectPath + projectName+ "/src/main/java");
        gc.setAuthor("tom");
        gc.setOpen(false);
        // 实体属性 Swagger2 注解
        gc.setSwagger2(true);
        // 默认覆盖文件
        gc.setFileOverride(true);

        // 设置全局配置
        mpg.setGlobalConfig(gc);

        // 数据源配置
        DataSourceConfig dsc = new DataSourceConfig();
        dsc.setUrl("jdbc:mysql://www.xxx.top:3306/upload_plat?useUnicode=true&characterEncoding=utf-8&useSSL=false&nullCatalogMeansCurrent=true");
        dsc.setDriverName("com.mysql.cj.jdbc.Driver");
        dsc.setUsername("root");
        dsc.setPassword("root");
        mpg.setDataSource(dsc);

        // 包配置
        PackageConfig pc = new PackageConfig();
//        pc.setModuleName(scanner("模块名"));
        pc.setParent("com.upload.user");
        pc.setEntity("entity");
        pc.setMapper("mapper");
        pc.setService("service");
        pc.setServiceImpl("service.impl");
        mpg.setPackageInfo(pc);

        // 自定义配置
//        InjectionConfig cfg = new InjectionConfig() {
//            @Override
//            public void initMap() {
//                // to do nothing
//            }
//        };

        // 如果模板引擎是 freemarker
//        String templatePath = "/templates/mapper.xml.ftl";
        // 如果模板引擎是 velocity
        // String templatePath = "/templates/mapper.xml.vm";

        // 自定义输出配置
//        List<FileOutConfig> focList = new ArrayList<>();
        // 自定义配置会被优先输出
//        focList.add(new FileOutConfig(templatePath) {
//            @Override
//            public String outputFile(TableInfo tableInfo) {
//                // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！
//                return projectPath + "/src/main/resources/mapper/" + pc.getModuleName()
//                        + "/" + tableInfo.getEntityName() + "Mapper" + StringPool.DOT_XML;
//            }
//        });
        /*
        cfg.setFileCreate(new IFileCreate() {
            @Override
            public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) {
                // 判断自定义文件夹是否需要创建
                checkDir("调用默认方法创建的目录");
                return false;
            }
        });
        */
//        cfg.setFileOutConfigList(focList);
//        mpg.setCfg(cfg);

        // 配置模板
        TemplateConfig templateConfig = new TemplateConfig();

        // 配置自定义输出模板
        //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别
        // templateConfig.setEntity("templates/entity2.java");
        // templateConfig.setService();
        // templateConfig.setController();

        templateConfig.setXml(null);
        mpg.setTemplate(templateConfig);

        // 策略配置
        StrategyConfig strategy = new StrategyConfig();
        strategy.setNaming(NamingStrategy.underline_to_camel);
        strategy.setColumnNaming(NamingStrategy.underline_to_camel);
        strategy.setSuperEntityClass("com.baomidou.mybatisplus.extension.activerecord.Model");
        strategy.setEntityLombokModel(true);
        strategy.setRestControllerStyle(true);

        strategy.setEntityLombokModel(true);
        // 公共父类
//        strategy.setSuperControllerClass("com.baomidou.ant.common.BaseController");
        // 写于父类中的公共字段
//        strategy.setSuperEntityColumns("id");

        // 若打开，则可以指定要逆向生成哪些表，若关闭，则是生成全部
        strategy.setInclude(scanner("表名，多个英文逗号分割").split(","));

        strategy.setControllerMappingHyphenStyle(true);
        strategy.setTablePrefix(pc.getModuleName() + "_");
        mpg.setStrategy(strategy);
        mpg.setTemplateEngine(new FreemarkerTemplateEngine());
        mpg.execute();
    }
}
```



##### 启动类上配置扫描路径

在项目启动类上配置 @MapperScan

``` java
@SpringBootApplication
@MapperScan("com.upload.user.mapper")
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}
```



#### 9.1.2 使用





### 9.2 结合Druid 配置多数据源

#### 9.2.1 配置 Druid

引入依赖

```xml 
<!-- MySql -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <version>8.0.11</version>
</dependency>
<!-- 连接池 -->
<!-- druid -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid-spring-boot-starter</artifactId>
    <version>1.1.22</version>
</dependency>
```

修改配置文件

```properties
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    druid:
      master-data-source:
        url: jdbc:mysql://www.xxx.top:3306/upload_plat?useUnicode=true&characterEncoding=utf-8&useSSL=false&nullCatalogMeansCurrent=true
        username: root
        password: root
      slave-data-source:
        url: jdbc:mysql://www.xxx.top:3306/upload_plat?useUnicode=true&characterEncoding=utf-8&useSSL=false&nullCatalogMeansCurrent=true
        username: root
        password: root
      initial-size: 10
      max-active: 100
      min-idle: 10
      max-wait: 60000
      pool-prepared-statements: true
      max-pool-prepared-statement-per-connection-size: 20
      time-between-eviction-runs-millis: 60000
      min-evictable-idle-time-millis: 300000
      validation-query: SELECT 1 FROM DUAL
      test-while-idle: true
      test-on-borrow: false
      test-on-return: false
      stat-view-servlet:
        enabled: true
        url-pattern: /druid/*
        #login-username: admin
        #login-password: admin
      filter:
        stat:
          log-slow-sql: true
          slow-sql-millis: 1000
          merge-sql: true
        wall:
          config:
            multi-statement-allow: true
```



#### 9.2.2 配置多数据源

修改启动类

```java
@SpringBootApplication(exclude = DataSourceAutoConfiguration.class)
@MapperScan("com.upload.user.mapper")
public class UserApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserApplication.class, args);
    }
}
```



增加配置类

```java
/**
 * 配置多数据源
 */
@Configuration
public class DynamicDataSourceConfig {

    @Bean
    @ConfigurationProperties("spring.datasource.druid.master-data-source")
    public DataSource defaultDataSource(){
        return DruidDataSourceBuilder.create().build();
    }

    @Bean
    @Primary
    public DynamicDataSource dataSource(DataSource defaultDataSource) {
        Map<String, DataSource> targetDataSources = new HashMap<>(2);
        targetDataSources.put(DataSourceEnum.MASTER.getName(), defaultDataSource);
        return new DynamicDataSource(defaultDataSource, targetDataSources);
    }
}
```

```java
/**
 * 动态数据源
 */
public class DynamicDataSource extends AbstractRoutingDataSource {

    private static final ThreadLocal<String> CONTEXT_HOLDER = new ThreadLocal<>();

    public DynamicDataSource(DataSource defaultTargetDataSource, Map<String, DataSource> targetDataSources) {
        super.setDefaultTargetDataSource(defaultTargetDataSource);
        super.setTargetDataSources(new HashMap<>(targetDataSources));
        super.afterPropertiesSet();
    }

    @Override
    protected Object determineCurrentLookupKey() {
        String currDataSource = getDataSource();
        return currDataSource;
    }

    /**
     * 设置数据源
     *
     * @param dataSource
     */
    public static void setDataSource(String dataSource) {
        CONTEXT_HOLDER.set(dataSource);
    }

    /**
     * 获取数据源
     *
     * @return
     */
    public static String getDataSource() {
        String dataSource = CONTEXT_HOLDER.get();
        // 如果没有指定数据源，使用默认数据源
        if (null == dataSource) {
            DynamicDataSource.setDataSource(DataSourceEnum.MASTER.getDefault());
        }
        return CONTEXT_HOLDER.get();
    }

    /**
     * 清除数据源
     */
    public static void clearDataSource() {
        CONTEXT_HOLDER.remove();
    }
}	
```

```java
/**
 * 数据源上下文
 */
public enum DataSourceEnum {

    MASTER("master-data-source", true),

    SLAVE("slave-data-source", false);

    private String name;

    private boolean master;

    DataSourceEnum(String name, boolean master) {
        this.name = name;
        this.master = master;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public boolean isMaster() {
        return master;
    }

    public void setMaster(boolean master) {
        this.master = master;
    }

    public String getDefault() {
        String defaultDataSource = "";
        for (DataSourceEnum dataSourceEnum : DataSourceEnum.values()) {
            if (!"".equals(defaultDataSource)) {
                break;
            }
            if (dataSourceEnum.master) {
                defaultDataSource = dataSourceEnum.getName();
            }
        }
        return defaultDataSource;
    }
}
```



### 9.3 使用 RestTemplate 发出 http 请求

#### 配置

由于 spring-boot-web 这个包里面已经封装了 RestTemplate，只需要引用即可

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <version>2.3.7.RELEASE</version>
</dependency>
```

由于没有自动注入进ioc容器，需要在启动类上手动注入

```java
@SpringBootApplication
public class Order80Application {
    public static void main(String[] args) {
        SpringApplication.run(Order80Application.class, args);
    }

    @Bean
    public RestTemplate restTemplate() {
        return new RestTemplate();
    }
}
```



#### 使用

```java
import com.tom.order80.entity.CommonResult;
import com.tom.order80.entity.Payment;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.client.RestTemplate;

import javax.annotation.Resource;

@RestController
public class OrderController {

    public static final String PAYMENT_URL = "http://localhost:18001";

    @Resource
    private RestTemplate restTemplate;

    @GetMapping("/consumer/payment/create")
    public CommonResult<Payment> create(Payment payment)
    {
        return restTemplate.postForObject(PAYMENT_URL +"/payment/add",payment, CommonResult.class);
    }

    @GetMapping("/consumer/payment/get/{id}")
    public CommonResult<Payment> getPayment(@PathVariable("id") Long id)
    {
        return restTemplate.getForObject(PAYMENT_URL+"/pay/find/"+id,CommonResult.class);
    }

    @GetMapping("/consumer/payment/getentity/{id}")
    public CommonResult<Payment> getPayment2(@PathVariable("id") Long id)
    {
        ResponseEntity<CommonResult> entity = restTemplate.getForEntity(PAYMENT_URL + "/pay/find/" + id, CommonResult.class);
        if(entity.getStatusCode().is2xxSuccessful()) {
            return entity.getBody();
        } else {
            return new CommonResult<>(444,"操作失败");
        }
    }
}

```



## 十、SpringBoot - 基础

### 10.1 自定义拦截器

先定义拦截器方法

```java
public class JwtInterceptor implements HandlerInterceptor {

    @Autowired
    private JwtUtil jwtUtils;

    /**
     * 拦截
     * @param request
     * @param response
     * @param handler
     * @return
     */
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // 静态资源请求拦截
        if (handler instanceof ResourceHttpRequestHandler) {
            return true;
        }

        // 有RestIgnoreAnon注解的方法不拦
        if (handler instanceof HandlerMethod) {
            HandlerMethod handlerMethod = (HandlerMethod) handler;
            if (handlerMethod.hasMethodAnnotation(RestIgnoreAnon.class)) {
                return true;
            }
        }

        // 若是忽略的，则直接通过
        String requestPath = request.getServletPath();
        Iterator<String> it = RestApiConstant.IGNORE_SET.iterator();
        while (it.hasNext()) {
            if(requestPath.indexOf(it.next()) == 0) {
                return true;
            }
        }

        return checkToken(request, response);
    }

    /**
     * token校验
     * @param request
     * @param response
     * @return
     */
    private boolean checkToken(HttpServletRequest request, HttpServletResponse response) {
        // 校验请求是否包含验证信息
        String token = getToken(request);
        String id = getId(request)==null?"0":getId(request);

        // token 为空
        if (StringUtils.isBlank(token)) {
            WebUtils.write(response, JSONUtils.beanToJson(ResData.error(ResCode.C().TOKEN_NOT_FOUNT, ResMsg.TOKEN_NOT_FOUNT)));
            return false;
        }

        return true;
    }
}
```



创建配置类注册拦截器

```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {

    /**
     * 添加jwt拦截器
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(jwtInterceptor())
                // 拦截所有请求，通过判断是否有 @JwtToken 注解 决定是否需要登录
                .addPathPatterns("/**");
    }

    /**
     * jwt拦截器
     * @return
     */
    @Bean
    public JwtInterceptor jwtInterceptor() {
        return new JwtInterceptor();
    }
}
```



### 10.2 控制返回时间戳格式

可以通过在 application.yml 中配置 jackson 实现：

- 控制返回前端的是时间戳还是可读时间
- 控制可读时间的显示

```properties
jackson:
    # 若不是时间戳，则以这个格式输出
    date-format: yyyy-MM-dd HH:mm:ss
    # 日期格式化的时区
    time-zone: GMT+8
    serialization:
      # 是否返回时间戳，若开启则不会返回可读格式
      write-dates-as-timestamps: true
```



### 10.3 已经引入了依赖包，打包时仍提示找不到类

查看是否有引入 `spring-boot-maven-plugin` 这个插件。若有则删除。

或改为：

```xml
<plugins>
    <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <version>2.4.1</version>
        <executions>
            <execution>
                <goals>
                    <goal>repackage</goal>
                </goals>
            </execution>
        </executions>
    </plugin>
</plugins>
```

实际上是 common 项目没有配置启动类的原因



## 十三、 Windows

### 13.1 关闭占用端口的程序

```markdown
# 查看特定端口被占用情况
netstat -ano|findstr 端口号

# 关闭占用端口的进程
taskkill /pid PID(进程号) /f
```



### 13.2 修改 hosts

```markdown
C:\Windows\System32\drivers\etc\hosts
```





## 十四、 Idea

### 14.1 idea 不显示 services 工具栏

![img](日常纪要.assets/20200526223956986.png)

找到 RunDashboard，在内部添加配置

![img](日常纪要.assets/20200526224125437.png)

![img](日常纪要.assets/20200526224200770.png)



**配置信息为：**

```markdown
<option name="configurationTypes">
  <set>
    <option value="SpringBootApplicationConfigurationType" />
  </set>
</option>
<option name="ruleStates">
  <list>
    <RuleState>
      <option name="name" value="ConfigurationTypeDashboardGroupingRule" />
    </RuleState>
    <RuleState>
      <option name="name" value="StatusDashboardGroupingRule" />
    </RuleState>
  </list>
</option>
```

**重启 IDEA， 并打开 Service**

![img](日常纪要.assets/20200526224355435.png)



### 14.2 idea 找不到或无法加载主类

这个问题往往是改了项目名称和目录导致的

![image-20210108211959309](日常纪要.assets/image-20210108211959309.png)



### 14.3 idea 不显示 .iml 和 .idea

![image-20210108213720655](日常纪要.assets/image-20210108213720655.png)









## 十五、Linux

### 15.1 根据进程ID查看进程

###### 根据进程名查看信息

```
ps -ef | grep tomcat
```



###### 根据端口查看对应进程(常用)

```
netstat -tunlp | grep 8080
```



根据进程 id 查看进程信息(常用)

```
ps -ef | grep 1095
```



###### 根据进程id查看占用的端口

```
netstat -nap | grep 1095
```



###### 根据进程名查看进程数

```
ps -ef|grep nacos|grep -v grep |wc -l
```



### 15.2 linux下无法删除文件的原因，提示：不允许的操作

https://www.cnblogs.com/liyuanhong/articles/9912386.html



### 15.3 linux 服务器间传输文件

```
scp -r "需要传输的文件" "接收文件服务器的用户名"@"接收服务器的ip":"文件接收路径"

//具体如下
scp -r /opt/birdchat/netty/* root@192.168.0.195:/opt/birdchat/netty
```





## 十六、Pom

### Maven 项目变为 SpringBoot

```xml
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <java.version>1.8</java.version>
    <spring.boot.version>2.3.7.RELEASE</spring.boot.version>
    <lombok.version>1.18.0</lombok.version>
</properties>
<dependencies>
    <!--  springboot相关 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
        <version>${spring.boot.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-dependencies</artifactId>
        <version>${spring.boot.version}</version>
        <type>pom</type>
        <scope>import</scope>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-actuator</artifactId>
        <version>${spring.boot.version}</version>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <version>${spring.boot.version}</version>
        <scope>test</scope>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>${lombok.version}</version>
    </dependency>
</dependencies>
```



### 项目引入 Redis 

```xml
<!--redis整合springboot-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>${spring.boot.version}</version>
</dependency>
<dependency>
    <groupId>redis.clients</groupId>
    <artifactId>jedis</artifactId>
    <version>3.2.0</version>
</dependency>
<dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.3.2</version>
</dependency>
```





# -----------  我是底  -----------



