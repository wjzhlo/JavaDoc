# jvm 复习

## jvm

### jvm、jdk、jre 分别是什么

- jvm：java virtual machine，即 java 虚拟机，负责装载字节码大内部，解释和编译为对应平台的机器指令。不同平台下的 jvm 都遵循着同一套指令和定义，实现一次编译，到处执行
- jdk：java 开发工具
- jre：java 运行时环境

在 jdk 包中，包含了 jre，jre 内部则包含了 jvm。同时 jdk 中还包含了 java 开发的各种工具类



### jvm 的生命周期

- 启动
  - 是随着引导类加载器(bootstrap class loader) 创建一个初始类来完成的
- 执行
  - 当 java 虚拟机运行时即执行过程，系统会给一个专门的 jvm 的进程
- 终止
  - 当程序正常执行结束，或是调用了system类或runtime类的 exit 方法
  - 程序执行时出现异常终止
  - 操作系统出现异常终止
  - jni通过本地方法栈来卸载 jvm





### jvm 的整体结构图

class files(二进制文件) => 类装载子系统(class loader) 

​                 =>  运行时数据区

执行引擎 							本地方法接口    <=   本地方法库



### 类的加载

#### 作用

`类的加载是负责从文件系统或网络中检查和加载 class 文件的过程。`

类加载器只负责加载 class 文件到内存中，至于是否可以运行，则由执行引擎决定



#### 过程

分为 加载 -> 链接 -> 初始化 三个阶段

- 加载
  - 先通过一个类的全限定类名(完整的包名)，获取到这个类的二进制字节流(即 class 文件)
  - 将这个 class 文件的内容转化为方法区的运行时数据结构
  - 在内存中生成一个代表这个类的 class 对象，作为方法区这个类的数据访问入口
- 链接
  - 验证
    - 即检查 class 文件是否正确，如开头为 cafe，可以用 jclass 查看
  - 准备
    - 为类变量分配内存，并设置默认的初始值0。但用 final 修饰的 static 常量会在这个过程中直接赋值。且如果变量是对象形式，则不会在这里初始化
  - 解析
    - 将常量池中的符号引用转换为直接引用。即在加载阶段时存储在方法区的符号引用，会被改为指向这个内存中分配好的内存空间的引用
- 初始化
  - clinit 和 init 方法
    - 在生成 class 文件时，会存储两个方法，一个是类的初始化方法 clinit()，一个是类的实例化方法 init()。
      - clinit 方法只会在类的加载阶段执行，仅执行一次，用于初始化类的静态变量和执行静态代码块。若一个类中没有静态变量和静态代码块，则不会存储 clinit() 方法
      - init 方法则是用于生成一个个实例的，在生成时会给变量分配内存空间，再执行赋默认值，之后执行赋值和代码块
  - 即执行类的构造方法的过程。即执行 clinit 方法。
- 使用
  - 使用 init 生成一个新的实例，这个实例会被单独分配内存空间
- 卸载
  - 程序执行结束



## 类的加载器

### 分类

主要分为引导类加载器和自定义类加载器

引导类加载器主要为：

- 启动类加载器 ( BootStrap Class Loader)
  - 用于加载 java 的核心库
- 扩展类加载器 ( Extension Class Loader )
  - 加载 jar 包以及 jdk 安装目录下 ext 目录中的类库
- 系统/应用类加载器 ( Application Class Loader )
  - 负责加载 classpath 或是系统的 java.class.path 下的类库，是最常用的类加载器，用户的自定义类加载器也是通过系统类加载器实现的



### 关系

三者是包含关系，而不是继承关系

- 启动类加载器没有父类
- 扩展类加载器和应用类加载器都继承自 ClassLoader 



### 委托关系

三者的使用是顺序关系

**委托顺序为：**

应用类加载器 --->  扩展类加载器 ---> 启动类加载器

调用顺序则与之相反，启动类加载器会先尝试进行加载。

加载时先向上委托，如果上层的加载器无法加载，才让子加载器进行处理，一层层调用·



### 双亲委派机制

#### 概念

`双亲委派机制即先尝试让父类进行处理，当父类还有父类时，继续向上委派。直到没有父类或父类无法处理时，又会依次下发。`

#### 作用

- 为了保护核心基础类不被篡改。如 String 类等。毕竟最顶级的加载器是启动类加载器，能够加载 java 的核心类库

- 避免类重复加载。如果类被父类的加载器处理了，就不会被其他加载器处理。保证了核心类最先被加载。若有我们自定义的类与核心类同名且全限定名相同，则自定义的类不会被加载



## 运行时数据区

### 作用

运行时数据区主要负责jvm进程运行时，加载的类数据以及数据存储和数据读写

- 类加载时会将运行时类写入方法区中
- 执行引擎运行时会不断读取和写入运行时数据区
- 存储线程数据



### 分类

按线程共享和线程私有区分：

- 线程共享
  - 方法区
  - 堆区
- 线程私有
  - 程序计数器
  - 本地方法栈(NMS)
  - 虚拟机栈(VMS)



### 程序计数器

#### 概念

`程序计数器中存储了下一个需要线程运行的命令的地址。程序计数器是线程私有的，每一个线程都有自己独立的程序计数器`

`cpu 完成一条指令的过程为：读取 => 译码 => 执行，而程序计数器在被译码之前指向当前正在运行的指令地址，当开始译码后，程序计数器会指向下一个需要执行的命令的地址`



#### 作用

由于 cpu 要不断切换各个线程，当线程被切换回来时，需要根据程序计数器来快速找到下一个要运行的指令是什么。同时为了提高效率，因此程序计数器是每个线程私有的，以保证线程运行时马上恢复状态



#### CPU 时间片

cpu 时间片即 cpu 分配给每个程序的时间，每个线程被分配一个时间段，cpu 按时间片让线程轮流执行。在这个时间段内运行，运行超过这个时间就挂起，等待下次运行。这就叫做线程的时间片。



### 虚拟机栈

#### 概念

`每个线程在创建时都会创建一个虚拟机栈，其内部存储了一个个栈帧，对应着一次次的 java 方法调用。一个栈帧就对应着一个 java 方法。`
`当有方法被调用时，就形成一个栈帧压入栈，而方法调用完毕后，则出栈。以此保证方法调用的层级关系以及数据返回`

- 线程私有的
- 一个栈结构，方法被调用就形成一个栈帧入栈，返回结果则栈帧出栈，以此保证方法调用的层级关系以及响应



#### 特点

- 分配快速
- 不存在垃圾回收，因为栈中的栈帧都是在使用，或是等待回调的。使用完的方法(栈帧)都已经出栈了
- 虽然不存在垃圾回收，但存在栈溢出的情况



#### 常见异常

- 栈大小固定：StackOverFlowError
  - 即栈容量超过了jvm允许的最大容量，如死循环的递归调用等导致的
- 栈大小不固定：OutOfMemoryError
  - 由于栈容量可以动态扩展，但在尝试扩展时无法申请到足够的内存空间，就会抛出这个异常



#### 栈帧的结构

栈帧是一个数据集，存储着方法运行的数据信息，结构为：

- 局部变量表
- 操作数栈：存储中间变量
- 动态链接：如对运行时常量池的方法的引用
- 方法返回地址：用于返回数据
- 附加信息



### 本地方法栈

#### 本地方法

java调用非java代码的接口

#### 本地方法栈

管理本地方法



### 堆

#### 概念

`堆是 jvm 内存的核心区域，所有的对象实例以及数组都会在实例化和运行时分配到堆上。且堆中的数据不是马上被回收的，而是有专门的 GC 线程进行回收处理`



#### 堆的内存结构

##### 结构划分

- JAVA7 及之前的堆内存，分为：新生代 + 老年代 + 永久区

- JAVA8 及之后将方法区改为元空间，即：新生代 + 老年代 + 元空间

- 新生代中又分为伊甸园区和幸存者区



##### 名词约定

- 新生代  = 年轻代 = 新生区
- 老年代 = 养老区 = 老年区
- 永久代 = 永久区



#### 新生代和老年代

##### 概念

- 年轻代
  - 年轻代中主要存储了生命周期较短的瞬时对象，即刚创建，以及快速消亡的对象，如临时变量等
- 老年代
  - 老年代中存储着生命周期很长的对象，或是内存占用很大的对象。如连接对象等
- 比例
  - 二者的比例默认为： 新生代 : 老年代 =1 : 2



##### 年轻代结构

主要分为：

- eden 区
- survivor0 区
- survivor1 区

三者比例为： eden : survivor0 : survivor1 = 8 : 1 : 1，但由于内部会自动调整，因此不一定严格按照比例



##### 对象分配流程

###### 年轻代回收

- 对象一开始创建时，直接被放入 eden 区，且给每个对象都加上各自的年龄计数器。当要放入数据到 eden 区，发现 eden 区满了之后，就会触发 YoungGC 来回收 eden 区的垃圾数据，同时将新的数据放入 eden 区中。
- 当触发 YoungGC 时，若存在仍在使用的对象时，会将对象从 eden 区移动到 S0 或 S1 区中
- YoungGC 的回收为：
  - 判断当前 S0 为空还是 S1 为空，将 Eden 区仍需要使用的对象，以及另一个不为空的幸存者区的数据，一起放入到空的幸存者区中，同时年龄计数器+1
  - 若年龄计数器记录的年龄达到15(默认，可修改)，则会触发晋升操作，将这个对象从幸存者区移动到老年代中

- 当对象很大，eden 区不够大时，对象会直接被放入老年代中。若老年代也放不下，则触发 FullGC，若 FullGC 后依然放不下，则会报 OOM 异常



###### 幸存者晋升

幸存者区内的对象晋升情况：

- 对象的年龄计数达到阈值(默认15)
- 整个 survivor 区内相同年龄的所有对象大小总和大于 survivor 空间的一半，则年龄大于等于这个年龄的对象可以直接进入老年代



##### GC 类型

###### 分类

- 新生代收集： YoungGC/MinorGC
  - 仅收集新生代
- 老年代收集：OldGC/MajorGC
  - 只有 cms 回收器会单独回收老年代
  - 大部分情况都是老年代满了，触发 FullGC
- 混合收集： MixedGC
  - 收集整个新生代以及部分老年代的垃圾收集
  - 目前只有 G1 回收器有这种行为
- 整堆收集： FullGC
  - 收集整个 java 堆和方法区的垃圾收集，一般是老年区满了触发



###### STW

stop the world，即在执行垃圾回收算法时，将除 GC 线程外的线程都挂起，实现一种全局暂停的现象。此时所有 java 代码停止，native 代码可以执行，但不能与 jvm 交互



###### Minor GC

- 触发条件
  - 当年轻代空间不足时触发，这里的触发指 eden 区满。survivor 满则是触发晋升
- 特点
  - minorgc 会引发 stw，停止用户线程。但由于年轻代内存空间小，回收快，因此对用户线程的影响较小



###### Major GC

- 触发条件
  - 当老年代空间不足时触发
- 特点
  - 有老年代空间更大，因此 stw 的时间更长



###### Full GC

- 触发条件
  - 老年代空间不足
  - 方法区空间不足
- 特点
  - 回收整个堆区和方法区，用户线程挂起时间长，因此 FullGC 应该尽量避免



##### 为什么要分代

如果不分代则要将所有的对象都放在一起，GC 每次回收都需要对堆的所有区域进行扫描。而通过分代可以将被快速销毁的对象放在一起，减少回收的时间



#### TLAB

`为了避免在并发环境下多线程操作同一地址，并提高效率，jvm 在 eden 区内为每个线程分配了一个私有缓冲区，这就是 tlab`

当线程中创建对象时，会优先在 tlab 空间中创建，但由于 tlab 空间很小，若 tlab 分配内存失败时，jvm 就会使用锁机制，在 eden 区中为其分配内存

> 即堆数据的分配优先在对应线程的 TLAB 空间中分配，如果 TLAB 分配内存失败，才使用锁的方式，在 eden 中寻址和分配



### 方法区

#### 概念

`方法区其实是一个概念，在 jdk1.8 之前是永久代，在 jdk1.8 及之后是元空间。主要存放已被虚拟机加载的类型信息、运行时常量池、静态变量、即时编译器编译后的代码缓存等。用 static final 修饰的常量也是存储在方法区中`



#### 常量池和运行时常量池

##### 常量池

在 class 文件(字节码文件)中除了包含类的字段、方法、接口外，还包括了常量池表，常量池表中记录了对应的类名、方法名、参数名等对应的映射索引。在使用过程中直接使用这个索引作为标记，而不需要重复写入类信息，依次减少字节码文件的大小。



##### 为什么要有常量池

通过常量池可以让反复被使用的类用唯一索引代替，只需要记录一次类信息以及映射的索引即可。这样可以极大减少字节码文件的大小。



##### 运行时常量池

运行时常量池和常量池的区别在于常量池是存储在字节码文件中的，而运行时常量池则是方法区的一部分。在类加载的过程中会将常量池内的数据加载到运行时常量池中，以便在运行期间使用



> **结构**

- jvm 会为每个已加载的类或接口维护一个私有的运行时常量池，便于每个类或接口访问自己的常量。
- 部分在运行期解析后才能获得的方法或字段引用，在编译器时以符号地址的方式表示，而在运行期间会根据实际地址，将运行时常量池中对应的符号地址修改为真实内存地址
- 运行时常量池具备动态性，这点可以从符号地址变为内存地址看出



#### 永久代和元空间

##### 永久代和元空间的异同 

- 二者都可以设置初始值和最大值
- 元空间使用的是本地内存，即只要系统给 jvm 进程分配的用户空间不耗尽，就不会发生 OOM。而永久代则默认分配 21.75m，若超过则会报 OOM



##### 为什么要使用元空间

元空间和永久代最大的区别就是元空间使用了本地内存，极大增加了元空间的大小，不会容易造成 OOM



##### 元空间参数优化

元空间存在高水位线，初始时默认是21m，一旦触发到这个水位线，则会引发一次 FullGC，并重置和提高这个高水位线

- 如果高水位线设置的过低，则会频繁触发 FullGC
- 如果释放的空间过多，则降低该值

> 为了避免频繁 FullGC，建议将这个值设得高点



##### 结构变化

| JDK1.6及以前 | 有永久代，静态变量存储在永久代上                             |
| ------------ | ------------------------------------------------------------ |
| JDK1.7       | 有永久代，但已经逐步 “去永久代”，字符串常量池，静态变量移除，保存在堆中 |
| JDK1.8       | 无永久代，类型信息，字段，方法，常量保存在本地内存的元空间(方法区)，但字符串常量池、静态变量仍然在堆中。 |



##### 为什么字符串常量池要移动到堆中

在 jdk1.8 之前字符串常量池在永久代中，由于永久代只有在 FullGC 时才会触发，因此导致字符串常量池的回收效率不高。因此经字符串常量池移动到堆中，能够及时回收字符串常量



##### 为什么静态变量移动到堆中

静态变量的实际内容被放到了堆的老年代中，元空间的类信息中只存了对这个静态变量的引用



#### 本地内存/直接内存

本地内存即在操作系统给jvm分配的，除堆占用空间外的内存空间，也是元空间所占用的内存空间

##### 优点

访问速度优于堆



### 执行引擎

`即将字节码指令编译为对应平台上的本地机器指令`



### 字符串常量池

#### String 的基本概念

##### 创建方式

- 字面量方式定义
  - String s1 = "hello"
  - 字面量方式定义的字符串会被放入字符串常量池中，而 s1 保存的是对字符串常量池中对应对象的引用
- new String 方式定义
  - String s2 = new String("hello")
  - 使用这种方式定义，会创建两个对象，一个是在字符串常量池中，另一个是在堆中，而此时的 s2 实际保存的是对堆中对象的引用
- 比较
  - s1 == s2， 比较的是二者的地址，返回为 false
  - 用 equals 比较，则比较的是二者的内容，返回为 true



##### 特点

- String 类被 final 修饰，不可被继承
- Stirng 实现了 Serializable 和 comparable 接口，是可序列化的，也可以比较大小
- String 在 jdk1.8 及之前使用 char[] 存储内容，而在 jdk9 开始改为 byte[]
- **不可变性：**即只要创建了就不可变，要变化只能创建一个新的 String 对象，变化如拼接、修改、删除
- **唯一性：**相同内容的字符串，在字符串常量池中仅会保存一份



#### String Table

##### 概念

String Table 是一个固定大小的 HashTable，默认大小是1009。若放入 Stirng Pool 的 String 非常对，则会造成严重的 Hash 冲突，导致链表会很长，这会降低新的字符串放入字符串常量池中的效率



#### 变化

##### 长度变化

- jdk6中，stringTable是固定的，就是1009的长度，所以如果常量池中的字符串过多就会导致效率下降很快
- jdk7中，stringTable的长度默认值是60013
- jdk8中，StringTable的长度默认值是60013，允许设置的最小值为1009
- jdk9中，StringTable 将原本存储内容的 char[] 改为了 byte[]



##### 内存分配变化

- jdk6 及以前
  - 字符串常量池存放在永久代中
  - 存在回收困难，占用大量内存，容易造成OOM
- jdk7 及之后
  - 将字符串常量池的位置调整到堆中
  - 能够调整堆空间大小降低OOM发生的风险
  - 将字符串常量放在新生代中，便于及时回收释放内存



#### 字符串拼接

- 字符串常量和字符串常量的拼接结果在直接放在常量池中，这是编译期优化的结果
- 字符串拼接时只要有一个是 new 出来的变量，则结果会存储在堆中



##### String、StringBuffer、StringBuilder

在JDK5之后，使用的是StringBuilder，在JDK5之前使用的是StringBuffer

| String                                                       | StringBuffer                                                 | StringBuilder    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------- |
| String的值是不可变的，这就导致每次对String的操作都会生成新的String对象，不仅效率低下，而且浪费大量优先的内存空间 | StringBuffer是可变类，和线程安全的字符串操作类，任何对它指向的字符串的操作都不会产生新的对象。每个StringBuffer对象都有一定的缓冲区容量，当字符串大小没有超过容量时，不会分配新的容量，当字符串大小超过容量时，会自动增加容量 | 可变类，速度更快 |
| 不可变                                                       | 可变                                                         | 可变             |
|                                                              | 线程安全                                                     | 线程不安全       |
|                                                              | 多线程操作字符串                                             | 单线程操作字符串 |



#### intern()

intern() 方法用于将字符串放入字符串常量池中。在调用 intern() 方法时

- 若池中已经包含了由 equals() 方法确定的与该字符串内容相同的字符串，则会返回池中的字符串对象
- 若池中没有相同的字符串，则会在池中新建一个字符串对象，并返回池中对象引用

`当存在大量重复字符串时，使用 intern() 可以避免创建重复的 String 对象`



## 垃圾回收

### 什么是垃圾

`垃圾就是指内存中没有任何指针指向的对象，如果这部分对象不被回收则会一直占用内存空间，最终导致内存溢出`



### 垃圾回收的相关算法

#### 标记阶段

##### 引用计数算法

`引用计数算法即对每一个对象都保存一个引用计数器属性，用于记录对象的被引用数量`

当多选被引用了，引用计时器加1，当引用失效时，引用计数器减1。让引用计数器为0时，这个对象就可以被回收了



###### 优缺点

- 优点
  - 实现简单，垃圾对象便于辨识
  - 判断效率高，回收没有延迟
- 缺点
  - 需要加个引用计数器，造成二开内存开销
  - 每次赋值都要更新计数器
  - `无法处理循环引用的情况`





##### 可达性分析算法

`可达性分析算法即通过一个根对象 GCRoots，所有的对象都是直接或间接地与根对象连接。而没有与根对象直接或间接连接的对象，则是垃圾对象`

> **注意：** 可达性分析算法标记的是可达对象，不是死亡对象



###### 优缺点

相对于引用计数算法，可达性分析算法同样具备实现简单和执行高效的特点，同时还解决了引用计数算法的循环引用问题



###### GCRoot 可以是那些

如果一个指针，它保存了堆内存中的堆，但自己又不存放在堆内存中，就可以成为一个 GCRoot。如虚拟机栈中引用的对象。或是一些放在老年代中的对象，这些对象创建的对象放入新生代中，这时老年代的对象也可以当做 GCRoot



##### 对象的 finalization 机制

`finalization 方法是用于自定义对象被销毁之前的处理逻辑，垃圾回收垃圾对象之前，总会先调用垃圾对象的 finalize() 方法`

通常在这个方法中进行一些资源释放和清理的工作，比如关闭文件、套接字和数据库连接等



#### 清除阶段

##### 标记-清除算法(Mark-Sweep)

`在使用可达性分析算法标记可达对象后，gc线程对堆内存从头到尾遍历，若发现某个对象不是可达对象，则将其回收`

> **注意：**这里的清除并不是真的置空，而是将需要清除的对象地址，下次有新的对象需要加载时，判断位置是否足够，足够则覆盖原有的地址。即不会清除原本的内容，只会覆盖



###### 缺点

- 标记清除算法的效率不高，需要从根节点开始从头到尾遍历
- 执行标记和清除时需要stw
- `这种方式清理出来的空闲内存是不连续的，会产生碎片，因此需要维护一个空闲列表`
- 由于内存碎片不连续，无法分配大小大于最大内存碎片空间的对象，但其实剩余的空闲内存之和，是可以放得下这个对象的



##### 标记-压缩算法(Mark-compact)

`标记压缩算法就是在使用可达性分析算法标记可达对象后，gc线程从头到尾遍历，回收不可达对象。在全部回收完成后，再讲所有可达对象整齐地排列到一遍。`



###### 优缺点

优点

- 解决了标记-清除算法中内存碎片的问题
- 降低了维护开销，需要给新对象分配内存时，只需要持有一个内存起始地址即可
- 充分利用了内存空间

缺点

- 由于多了碎片整理这个流程，因此效率要低于标记-清除算法
- 在碎片整理过程中移动对象，若这个对象被引用，则需要调整引用的地址
- 碎片整理的过程也需要 stw



##### 标记-清除算法和标记-压缩算法的区别

- 流程不同
  - 标记压缩算法比标记清除算法多了一步碎片整理
- 本质不同
  - 标记清除算法是不会移动对象的，而标记压缩算法会移动存活对象，并修改对象的引用地址
- 维护开销
  - 标记清除算法需要额外维护一张空心列表，表明哪些位置可以存放新的对象。而标记压缩算法中只需要记录一个内存的起始地址即可
- OOM 风险/内存利用率
  - 标记清除算法的内存空间是碎片化的。而标记压缩算法的内存空间是整段的。因此标记压缩算法能够更大限度地利用内存空间，同时也降低了OOM的风险



##### 复制算法(copying)

`复制算法即将内存空间分为两块，每次仅适用其中一块。在垃圾回收时将正在适用的内存块中的可达对象复制到另一个内存块中，全部完成后清理原本的内存块，依次循环`

> **注意：**复制算法是复制对象，不是移动对象

###### 优缺点

优点

- 没有标记和清除的过程，实现简单，高效
- 复制到新的内存块中时能够保证内存空间的连续性，不会出现碎片化

缺点

- 内存利用率低
- 需要维护对象的引用关系



###### 适用情况

不适用大量对象存活的情况，更适用于少量存活对象，大量垃圾对象的情况。如新生代的 survivor 区中



##### 分代收集算法

`分代收集算法即对新生代和老年代采用不同的垃圾回收算法。新生代中对象生命周期短、存活率低、回收频繁，故采用复制算法。而老年代则使用标记-压缩算法或标记-清除算法`



##### 增量收集算法

`增量收集算法即通过对内存进行分片收集，每次都只收集一小片的内存空间，降低 stw 的时间。实际底层使用的还是标记-清除算法或复制算法`

###### 优缺点

- 增量收集算法每次仅回收一小块的内存区域，能够有效减少系统的停顿时间
- 由于不断在用户线程和垃圾回收线程间切换，造成线程切换开销，使得系统吞吐量下降



##### 分区算法

`分区算法是将堆空间分割成一个个独立的小块内存，每个小块都可以独立回收。通过控制一次回收多少个块来控制gc造成的停顿时间。当要给对象分配内存时，会将对象分配到对应区域，并标记当前区域归属的堆的位置`

> G1 回收期就是使用了分区算法进行垃圾回收的



### 垃圾回收的相关概念

#### 跨代引用

`跨代引用是指新生代中存在对老年代的引用，或是老年代中存在对新生代的引用`

通过记忆集的方式处理，G1 中已经有了记忆集。

或是通过修改参数，让回收器在 Major GC（OGC）之前先进行一次 Minor GC（YGC）

https://blog.csdn.net/weixin_30979383/article/details/112542930

https://blog.csdn.net/ning0323/article/details/76039150



#### 内存溢出

`无法为对象开辟足够的内存空间`

原因可能有：

- 堆内存设置太小或创建的对象太大
- 存在内存泄漏占用大量堆空间

>  例子：

在 idea 中设置内存限制

```
-Xms10m -Xmx10m
```

```java
public class OOMTest {
    public static void main(String[] args) {
        List<String> array = new ArrayList<>();
        for (int i = 0; i < 1000000; i++) {
            array.add(new String("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"));
        }
    }
}
```



#### 内存泄漏

`当对象不会被程序用到，但gc又无法回收他们`

原因可能有：

- 单例模式下，由于单例对象的生命周期与应用周期一样长，若在单例对象中持有对外部对象的引用，则这个外部对象是无法回收的
- 连接未关闭导致，如数据库连接，网络连接，io等

> 例子

```java
@Component()
public class SomeUtils {

    @Autowired
    private RedisConfig redisConfig;
    
    private List dataList;

    construct() {
        this.dataList = new ArrayList();
    }
    
    // 由于 SomeUtils 是交给IOC管理的，因此dataList中会一直持有对user的引用。造成内存泄漏
    public Long addUser(User user) {
		dataList.add(user);
    }
}
```



#### 垃圾回收的并行和并发

##### 并发和并行

###### 并行

`当系统上有多个cpu时，每个cpu都可以独立运行自己的进程，此时各个cpu内的线程就可以看做是并行。决定是否并行取决于cpu的核心数量，而不是cpu的`



###### 并发

`并发是指在一个cpu核心上，多个线程轮流执行的情况`



###### 并发和并行的对比

- 执行不同
  - 并发是指在同一个时间段内，发生了多个事情。实际上是给线程分配了各自的时间片，切换时间片执行对应线程实现的
  - 并行则是在同一个时间点上，发生了多个事情。这是由于多个cpu核心互不干扰，可以独立运行各自的线程、
- 资源使用
  - 并发是多个任务之间抢占资源
  - 并行则不同cpu核心的线程之间是隔离的



##### 垃圾回收中的串行、并行、并发

###### 并发

多条垃圾回收线程并发工作，如 ParNew、Parallel Scavenge、Paraallel old



###### 串行

相较于并行，串行则是单条垃圾回收线程进行工作



###### 并行

用户线程和垃圾回收线程是同时执行的，即垃圾回收线程在执行时不会停止用户线程的运行，即他们在不同的cpu核心上工作，如 CMS、G1



#### 安全点和安全区域

##### 安全点

`程序在执行过程中不是什么时候都可以stw执行gc的，只有在特定的位置才能停下来，这些位置就称为安全点`



##### 安全区域

`安全区域是指在一段代码片段中，对象的引用关系不会发生变化，则在这个区域的任何位置都是gc安全的`





### 强软弱虚

- 强引用
  - 只要引用关系还存在，对象就不会被回收
- 软引用（SoftReference）
  - 若引用了软引用的对象，没有强引用，jvm 会在即将 OOM 之前强制回收软引用关联的对象
- 弱引用（WeakReference）
  - 若引用了弱引用的对象，没有强引用，jvm 会在下次垃圾回收时将这个对象回收
- 虚引用（PhantomReference）
  - 虚引用等同于形同虚设，不会影响对象的生命周期，用于对象的回收跟踪



### 垃圾回收器

#### 不同版本使用的垃圾回收器

一般垃圾收集器都是通过组合的方式进行堆的回收的，

- JDK 8
  -  默认使用 Parallel Scavenge + Parallel 0ld

- JDK9
  - 默认使用 G1



#### 垃圾回收器类型

- 针对新生代回收
  - Serial：`串行回收`，使用`复制算法`
  - ParNew：`并行回收`，使用的也是`复制算法`
  - Parallel Scavenge：`并行回收`，使用`复制算法`，吞吐量优先策略，提供自适应调节策略，能够自动分配内存结构，减少 stw 时间，提高吞吐量。可以手动设定年轻代并发回收的线程个数
- 针对老年代回收
  - Serial Old：串行回收，使用的是标记压缩算法
  - Parallel Old：并行回收，使用标记压缩算法
  - CMS：最短停顿时间回收，使用标记清除算法，是第一个真正意义上的并发收集器，实现了让垃圾收集线程与用户线程同时工作。但 cms 无法与 paraller scavenge 配合工作，因此使用 cms 作为老年代回收期时，年轻代只能用 serial 或 parnew
- 整堆回收
  - G1：垃圾优先回收器，通过将内存分区域存储，标识区域属于年轻代还是老年代，同时跟踪各个区域中的垃圾堆积性价比(回收释放的空间大小以及回收所需的时间)，优先释放性价比更高的区域，同时兼顾了低延迟和高吞吐量的特点。`适用于配备多核cpu以及大容量内存的机器`
    - G1 可能只会回收整个年轻代+部分老年代，而不是像其他垃圾回收器一样回收整个老年代
    - G1 在 jdk7 版本启动，jdk9 中设置默认的垃圾回收器



#### CMS 回收器

`CMS 回收器关注最低延迟，即尽可能缩短stw的时间。采用标记清除算法，是第一款真正意义上的并发收集器，实现让垃圾收集线程和用户线程同时工作`



##### 处理过程

处理过程大致为：初始标记、并发标记、重新标记、并发清除四个阶段

- **初始标记(stw)：**在这个阶段会触发stw，垃圾回收线程开始标记所有==直接可达==的对象，标记完成后恢复挂起线程。由于直接关联的对							象都很少，因此这部分的速度非常快

- **并发标记：**这个阶段是从初始标记阶段标记的直接可达对象开始，遍历获取其他可达对象的过程。这个过程耗时较长但不用stw

- **重新标记(stw)：**由于在并发标记阶段用户线程也在执行，可能会导致部分标记产生变动，因此这阶段会触发stw，对这些变动对象重新标记。这部分耗时也远低于并发标记的时间

- **并发清除：**在前面的三个阶段已经标记出了所有可达对象，因此在这个阶段直接删除掉死亡对象即可。且由于并发删除的过程中不需要移动存活对象，因此也是与用户线程并发执行的




##### 为什么 CMS 回收器不采用标记整理算法

由于在并发清除阶段是垃圾回收线程和用户线程并发执行的，并没有触发stw，因此不可以移动可达对象，否则用户线程会无法正常访问到对应的对象



##### 优缺点和优化

- 优点
  - 并发收集
  - 低延迟，stw 时间更短
- 缺点
  - 内存碎片化
  - 并发标记阶段会占用cpu资源，导致吞吐量降低
  - cms 处理器无法处理浮动垃圾，即过了重新标记阶段后，产生的新垃圾对象只能在下一次gc时才能释放
- 优化
  - 可以通过参数指定在执行完多少次FullGC后对老年代进行压缩整理
  - 可以调整CMS线程数量，来调整cms线程和用户线程的比例



##### 内存回收阈值

> **-XX:CMSInitiatingoccupanyFraction** 
>
> 设置堆内存使用率的阈值，一旦达到该阈值，便开始进行回收。

cms 回收器不会等到老年代内存满了才进行回收，而是达到使用率阈值就开始回收

jdk5及以前版本默认为 68%，之后默认为 92%

- 如果内存增长缓慢，则可以将这个阈值调高，以此降低cms回收的频率
- 如果内存增长较快，则应该降低这个阈值，避免触发 FullGC



#### G1 回收器

`G1 回收器是将 Eden，Survivor、Old 都打散到，分散到各个块中。G1 会跟踪这些 region 里面的垃圾堆积的性价比(通过回收后释放的内存空间以及回收时间)来维护一个优先列表，优先回收性价比最高的 region`



##### 回收模式

G1 提供了三种回收模式，分别在不同的条件下触发

- YoungGC
  - 当 Eden 用尽时触发 YGC，会触发stw，并行地收集和清理垃圾
- MixedGC
  - 当内存使用率达到一定值(默认45%)时，开始混合回收过程。会通过回收优先列表进行回收
  - 混合回收过程中，是回收所有的年轻代和部分老年代。在回收过程中，会将块中的可达对象移动到堆内存一端的空间区间中
  - 混合回收是逐步回收老年代的，因此当触发混合回收时，往往会有多次混合回收



##### Region

- G1 将堆内存划分为2048个块，块大小根据堆空间大小而定。
- 每个块大小相同
- 每个块初始时都是状态的，可以存储任意部分的数据
- 同样支持 TLAB
- 增加 Humongous 区存放大对象，若对象大小超过 1.5 region，则会被放入 Humongous 中



### cms 和 G1 对比

- 使用范围不同
  - CMS 适用于老年代收集，而 G1 适用于整个堆空间收集
- stw 时间不同
  - CMS 使用的是最短停顿时间，而 G1 则是使用可预测停顿时间的方式
- 垃圾碎片
  - CMS 使用的是标记清除算法，会产生内存碎片，而G1 则使用标记整理算法，回收过程中逐步将数据整理到内存的一端

