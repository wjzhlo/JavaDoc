# RocketMQ 复习

## MQ 背景

### 什么是MQ

mq 即消息队列，是一种先进先出的结构，主要用于应用解耦、流量削峰、数据分发、分布式事务回滚等



### 常见作用

- **应用解耦**
  - 即通过队列的发布订阅模式将数据分发到不同的服务中，避免不同模块中的代码耦合
- **流量削峰**
  - 即当请求猛增时，mq 中可以先缓存大量数据，并让消费者线程消费
- **数据分发**
  - 各个系统订阅自己感兴趣的话题，当话题中有新消息时会通知消费者来获取，同时可以动态扩展
- **分布式事务回滚**
  - 微服务间当要进行事务回滚时，可以发出回滚的消息让服务进行回滚



### 常见 MQ 产品的比较

常见的 mq 有 rabbitmq、rocketmq、kafka、activemq

| 特性           | ActiveMQ | RabbitMQ | RocketMQ             | Kafka              |
| -------------- | -------- | -------- | -------------------- | ------------------ |
| **语言**       | java     | erlang   | java                 | scala              |
| **吞吐量**     | 万级     | 万级     | 十万级               | 十万级             |
| **时效性**     | 毫秒级   | 微秒级   | 毫秒级               | 毫秒级             |
| **可用性**     | 主从     | 主从     | 高                   | 高                 |
| **社区活跃度** |          |          | 社区活跃度最高       |                    |
| **持久化**     |          |          |                      |                    |
| **完整性**     |          |          | mq功能完善，扩展性佳 | 仅支持主要的mq功能 |



## RocketMQ 基础

### RocketMQ 角色

- Producer：消息发送者
- Consumer： 消息接收者
- Broker：暂存和传输消息
- NameServer：管理 Broker
- Topic：话题，一个发送者可以发送消息给一个或多个 Topic，而接收者可以订阅一个或多个 Topic
- Message Queue：相当于 Topic 的分区，用于并行发送消息和并行接收消息

<img src="rocketmq 复习.assets/20200625121652498.jpg" alt="img" style="zoom: 50%;" />



### 流程



### 搭建

#### 配置文件修改

rocketmq 默认占用的虚拟机内存为8G，需要根据实际情况修改

即 `bin/runbroker.sh` 中

可以调整的参数：

- -xms：最小堆内存大小
- -xmx：最大堆内存大小
- -xmn：堆内新生代大小，默认新生代：老年代=1:2，但由于消息消费情况良好时，可以提高新生代的内存大小，又是用了 G1 垃圾回收器，因此新生代的内存大小不会影响性能

https://blog.csdn.net/u010013573/article/details/88782757

https://www.cnblogs.com/pass-ion/p/14116106.html



#### 启动顺序

先启动 namesrv，再启动 broker



### 发送消息方式

rocketmq 支持三种发送消息的方式：同步消息、异步消息、单向消息

#### 同步消息

`可靠性较高的消息发送方式，会阻塞线程直到 mq 返回结果，通常用于重要消息的发送，如短信等`

直接调用 send 方法发送即可



#### 异步消息

`用于对响应时间敏感的业务场景，即发送端不能长时间地等待 Broker 响应，通常用于大并发量的数据发送。可以在发送后通过回调函数知晓发送成功还是失败`

调用 send 方法，第一个参数为 Message ，第二个参数为 callBack 函数



#### 单向消息

`用于不关心发送结果的场景，如日志`

调用 sendOneway 方法



### 消费者消费方式

通过 setMessageModel 方式设置

- 负载均衡模式 MessageModel.CLUSTERING
- 广播模式 MessageModel.BROADCAST

#### 负载均衡/集群模式(默认)

负载均衡模式即当多个消费者共同消费队列信息时，每个消费者获取的消息都不同

#### 广播模式

广播模式即只要每个消费者订阅的 topic 和 tag 相同，则每个消费者都会获取到同一条消息



### 消息类型

#### 类型

- 顺序消息

- 延时消息
  - 延时消息即消息被提供者发送到队列中后，不会被立即消费，而是在过了设定的时间后，才会被消费者消费
  - 可以用在电商项目中，如当用户发起一个订单却没付款，则订单在数据库中会变成脏数据，因此在用户发起订单后，同时发送一个延时消息到队列中，隔了一段时间后这条消息被消费时，判断是否订单已付款，未付款则取消订单

- 批量消息
  - 支持将订阅相同 topic 的消息一起发送，不能是延时消息，且总大小不能超过4M

- 过滤消息
  - 用 sql 过滤

- 事务消息



#### 顺序消息

RocketMQ 支持按照消息的发送顺序来消费 FIFO，即保证消息的有序性，分为分区有序和全局有序

每个 broker 中都维护着对个队列，要保证消息有序，则只能将要保持有序的消息，都放到同一个队列中

- **全局有序：**
  - 只有一个队列，所有的消息都往那个队列扔
- **分区有序：**
  - 存在多个队列，但要保证有序的消息会被扔到同一个队列中。分区即扔到一个单独的队列中



### 消息堆积处理

https://www.cnblogs.com/wlwl/p/10668197.html

另开一个 new_topic，开服务将旧的 topic 的消息读取到新的 topic 中，新的 topic 开更多的队列，让消费者去这个新的 topic 消费以保证快速消费





### RocketMQ 调优

https://cloud.tencent.com/developer/article/1496414

参数调优：

https://www.cnblogs.com/qdhxhz/p/11116197.html



### 面试题

https://blog.csdn.net/lettyisme/article/details/85233008









